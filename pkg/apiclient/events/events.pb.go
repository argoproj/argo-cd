// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: server/application/events.proto

// Events Service
//
// Events Service API provides a generic event-source that allows
// listening for argo-cd events natively from argo-events.

package events

import (
	context "context"
	fmt "fmt"
	_ "github.com/argoproj/argo-cd/v2/pkg/apis/application/v1alpha1"
	_ "github.com/gogo/protobuf/gogoproto"
	github_com_gogo_protobuf_proto "github.com/gogo/protobuf/proto"
	proto "github.com/gogo/protobuf/proto"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type EventSource struct {
	// The event source name.
	Name *string `protobuf:"bytes,1,req,name=name" json:"name,omitempty"`
	// The event source configuration value.
	Config               []byte   `protobuf:"bytes,2,opt,name=config" json:"config,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EventSource) Reset()         { *m = EventSource{} }
func (m *EventSource) String() string { return proto.CompactTextString(m) }
func (*EventSource) ProtoMessage()    {}
func (*EventSource) Descriptor() ([]byte, []int) {
	return fileDescriptor_3ad9267ec62b112f, []int{0}
}
func (m *EventSource) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventSource) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventSource.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventSource) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventSource.Merge(m, src)
}
func (m *EventSource) XXX_Size() int {
	return m.Size()
}
func (m *EventSource) XXX_DiscardUnknown() {
	xxx_messageInfo_EventSource.DiscardUnknown(m)
}

var xxx_messageInfo_EventSource proto.InternalMessageInfo

func (m *EventSource) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *EventSource) GetConfig() []byte {
	if m != nil {
		return m.Config
	}
	return nil
}

//*
// Represents an event
type Event struct {
	// The event source name.
	Name *string `protobuf:"bytes,1,req,name=name" json:"name,omitempty"`
	// The event payload.
	Payload              []byte   `protobuf:"bytes,2,req,name=payload" json:"payload,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Event) Reset()         { *m = Event{} }
func (m *Event) String() string { return proto.CompactTextString(m) }
func (*Event) ProtoMessage()    {}
func (*Event) Descriptor() ([]byte, []int) {
	return fileDescriptor_3ad9267ec62b112f, []int{1}
}
func (m *Event) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Event) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Event.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Event) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Event.Merge(m, src)
}
func (m *Event) XXX_Size() int {
	return m.Size()
}
func (m *Event) XXX_DiscardUnknown() {
	xxx_messageInfo_Event.DiscardUnknown(m)
}

var xxx_messageInfo_Event proto.InternalMessageInfo

func (m *Event) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *Event) GetPayload() []byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

//*
// The actual object that will be send
// with each event.
type EventPayload struct {
<<<<<<< HEAD
	Timestamp string `protobuf:"bytes,1,req,name=timestamp" json:"timestamp"`
=======
	Timestamp v1.Time `protobuf:"bytes,1,req,name=timestamp" json:"timestamp"`
>>>>>>> d7c1eeaa8f49ce0d66164a03ba87bacc8accab5e
	// The object that the event is about
	Object []byte `protobuf:"bytes,2,req,name=object" json:"object,omitempty"`
	// The object source information
	Source               *ObjectSource `protobuf:"bytes,3,req,name=source" json:"source,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *EventPayload) Reset()         { *m = EventPayload{} }
func (m *EventPayload) String() string { return proto.CompactTextString(m) }
func (*EventPayload) ProtoMessage()    {}
func (*EventPayload) Descriptor() ([]byte, []int) {
	return fileDescriptor_3ad9267ec62b112f, []int{2}
}
func (m *EventPayload) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventPayload) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventPayload.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventPayload) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventPayload.Merge(m, src)
}
func (m *EventPayload) XXX_Size() int {
	return m.Size()
}
func (m *EventPayload) XXX_DiscardUnknown() {
	xxx_messageInfo_EventPayload.DiscardUnknown(m)
}

var xxx_messageInfo_EventPayload proto.InternalMessageInfo

<<<<<<< HEAD
func (m *EventPayload) GetTimestamp() string {
	if m != nil {
		return m.Timestamp
	}
	return ""
=======
func (m *EventPayload) GetTimestamp() v1.Time {
	if m != nil {
		return m.Timestamp
	}
	return v1.Time{}
>>>>>>> d7c1eeaa8f49ce0d66164a03ba87bacc8accab5e
}

func (m *EventPayload) GetObject() []byte {
	if m != nil {
		return m.Object
	}
	return nil
}

func (m *EventPayload) GetSource() *ObjectSource {
	if m != nil {
		return m.Source
	}
	return nil
}

//*
// Holds information about the object source
type ObjectSource struct {
	DesiredManifest      string   `protobuf:"bytes,1,opt,name=desiredManifest" json:"desiredManifest"`
	ActualManifest       string   `protobuf:"bytes,2,opt,name=actualManifest" json:"actualManifest"`
	GitManifest          string   `protobuf:"bytes,3,opt,name=gitManifest" json:"gitManifest"`
	RepoURL              string   `protobuf:"bytes,4,opt,name=repoURL" json:"repoURL"`
	Path                 string   `protobuf:"bytes,5,opt,name=path" json:"path"`
	Revision             string   `protobuf:"bytes,6,opt,name=revision" json:"revision"`
	AppName              string   `protobuf:"bytes,7,opt,name=appName" json:"appName"`
	SyncStatus           string   `protobuf:"bytes,8,opt,name=syncStatus" json:"syncStatus"`
	SyncStartedAt        v1.Time  `protobuf:"bytes,9,opt,name=syncStartedAt" json:"syncStartedAt"`
	SyncFinishedAt       *v1.Time `protobuf:"bytes,10,opt,name=syncFinishedAt" json:"syncFinishedAt,omitempty"`
	HealthStatus         *string  `protobuf:"bytes,11,opt,name=healthStatus" json:"healthStatus,omitempty"`
	HealthMessage        *string  `protobuf:"bytes,12,opt,name=healthMessage" json:"healthMessage,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ObjectSource) Reset()         { *m = ObjectSource{} }
func (m *ObjectSource) String() string { return proto.CompactTextString(m) }
func (*ObjectSource) ProtoMessage()    {}
func (*ObjectSource) Descriptor() ([]byte, []int) {
	return fileDescriptor_3ad9267ec62b112f, []int{3}
}
func (m *ObjectSource) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ObjectSource) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ObjectSource.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ObjectSource) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ObjectSource.Merge(m, src)
}
func (m *ObjectSource) XXX_Size() int {
	return m.Size()
}
func (m *ObjectSource) XXX_DiscardUnknown() {
	xxx_messageInfo_ObjectSource.DiscardUnknown(m)
}

var xxx_messageInfo_ObjectSource proto.InternalMessageInfo

func (m *ObjectSource) GetDesiredManifest() string {
	if m != nil {
		return m.DesiredManifest
	}
	return ""
}

func (m *ObjectSource) GetActualManifest() string {
	if m != nil {
		return m.ActualManifest
	}
	return ""
}

func (m *ObjectSource) GetGitManifest() string {
	if m != nil {
		return m.GitManifest
	}
	return ""
}

func (m *ObjectSource) GetRepoURL() string {
	if m != nil {
		return m.RepoURL
	}
	return ""
}

func (m *ObjectSource) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *ObjectSource) GetRevision() string {
	if m != nil {
		return m.Revision
	}
	return ""
}

func (m *ObjectSource) GetAppName() string {
	if m != nil {
		return m.AppName
	}
	return ""
}

func (m *ObjectSource) GetSyncStatus() string {
	if m != nil {
		return m.SyncStatus
	}
	return ""
}

func (m *ObjectSource) GetSyncStartedAt() v1.Time {
	if m != nil {
		return m.SyncStartedAt
	}
	return v1.Time{}
}

func (m *ObjectSource) GetSyncFinishedAt() *v1.Time {
	if m != nil {
		return m.SyncFinishedAt
	}
	return nil
}

func (m *ObjectSource) GetHealthStatus() string {
	if m != nil && m.HealthStatus != nil {
		return *m.HealthStatus
	}
	return ""
}

func (m *ObjectSource) GetHealthMessage() string {
	if m != nil && m.HealthMessage != nil {
		return *m.HealthMessage
	}
	return ""
}

func init() {
	proto.RegisterType((*EventSource)(nil), "generic.EventSource")
	proto.RegisterType((*Event)(nil), "generic.Event")
	proto.RegisterType((*EventPayload)(nil), "generic.EventPayload")
	proto.RegisterType((*ObjectSource)(nil), "generic.ObjectSource")
}

func init() { proto.RegisterFile("server/application/events.proto", fileDescriptor_3ad9267ec62b112f) }

var fileDescriptor_3ad9267ec62b112f = []byte{
<<<<<<< HEAD
	// 606 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x94, 0xd1, 0x6e, 0xd3, 0x3c,
	0x14, 0xc7, 0xbf, 0x74, 0xdd, 0xba, 0xb9, 0xdd, 0x3e, 0x64, 0x6d, 0x60, 0x4d, 0xd0, 0x45, 0xd1,
	0x84, 0x2a, 0xc4, 0x12, 0x5a, 0x40, 0x82, 0xcb, 0x4d, 0x82, 0xab, 0x0d, 0x50, 0x06, 0x48, 0x70,
	0xe7, 0xa5, 0x67, 0x89, 0xb7, 0xc4, 0xb6, 0x6c, 0x37, 0x52, 0x6f, 0x79, 0x05, 0x5e, 0x83, 0x07,
	0xd9, 0x25, 0x12, 0xf7, 0x08, 0x4d, 0x3c, 0x08, 0x8a, 0xeb, 0x75, 0xee, 0xe0, 0x02, 0xee, 0x7c,
	0xfe, 0xe7, 0x7f, 0x7e, 0x39, 0x47, 0x39, 0x36, 0xda, 0xd1, 0xa0, 0x6a, 0x50, 0x09, 0x95, 0xb2,
	0x64, 0x19, 0x35, 0x4c, 0xf0, 0x04, 0x6a, 0xe0, 0x46, 0xc7, 0x52, 0x09, 0x23, 0x70, 0x27, 0x07,
	0x0e, 0x8a, 0x65, 0xdb, 0x87, 0x39, 0x33, 0xc5, 0xe4, 0x24, 0xce, 0x44, 0x95, 0x50, 0x95, 0x0b,
	0xa9, 0xc4, 0x99, 0x3d, 0xec, 0x65, 0xe3, 0xa4, 0x1e, 0x25, 0xf2, 0x3c, 0x4f, 0xa8, 0x64, 0x7a,
	0x01, 0x55, 0x0f, 0x69, 0x29, 0x0b, 0x3a, 0x4c, 0x2c, 0x85, 0x1a, 0x18, 0xcf, 0xb0, 0xdb, 0x4f,
	0xce, 0x9f, 0xe9, 0x98, 0x89, 0xa6, 0xa2, 0xa2, 0x59, 0xc1, 0x38, 0xa8, 0xe9, 0x35, 0xa2, 0x02,
	0x43, 0x93, 0xfa, 0xf7, 0xaa, 0xcd, 0x5c, 0xd8, 0x0f, 0x1b, 0x91, 0x34, 0x27, 0xa7, 0xde, 0xcd,
	0x85, 0xc8, 0x4b, 0x68, 0x4a, 0x13, 0xca, 0xb9, 0x30, 0xf6, 0xdb, 0x6e, 0x80, 0xe8, 0x39, 0xea,
	0xbe, 0x68, 0x06, 0x3a, 0x16, 0x13, 0x95, 0x01, 0xc6, 0xa8, 0xcd, 0x69, 0x05, 0x24, 0x08, 0x5b,
	0x83, 0xb5, 0xd4, 0x9e, 0xf1, 0x6d, 0xb4, 0x92, 0x09, 0x7e, 0xca, 0x72, 0xd2, 0x0a, 0x83, 0x41,
	0x2f, 0x75, 0x51, 0xf4, 0x14, 0x2d, 0xdb, 0xd2, 0x3f, 0x16, 0x11, 0xd4, 0x91, 0x74, 0x5a, 0x0a,
	0x3a, 0x26, 0xad, 0xb0, 0x35, 0xe8, 0xa5, 0x57, 0x61, 0x34, 0x45, 0x3d, 0x5b, 0xf6, 0x66, 0x16,
	0xe3, 0x08, 0xad, 0x19, 0x56, 0x81, 0x36, 0xb4, 0x92, 0x33, 0xc4, 0x41, 0xfb, 0xe2, 0xfb, 0xce,
	0x7f, 0xe9, 0xb5, 0xdc, 0xb4, 0x20, 0x4e, 0xce, 0x20, 0x33, 0x0e, 0xe6, 0x22, 0xbc, 0x87, 0x56,
	0xb4, 0x6d, 0x9c, 0x2c, 0x85, 0xad, 0x41, 0x77, 0xb4, 0x15, 0xbb, 0xff, 0x11, 0xbf, 0xb6, 0x86,
	0xd9, 0x54, 0xa9, 0x33, 0x45, 0x5f, 0xda, 0xa8, 0xe7, 0x27, 0x70, 0x8c, 0xfe, 0x1f, 0x83, 0x66,
	0x0a, 0xc6, 0x47, 0x94, 0xb3, 0x53, 0xd0, 0x86, 0x04, 0x61, 0x30, 0xef, 0xe0, 0x66, 0x12, 0x3f,
	0x44, 0x1b, 0x34, 0x33, 0x13, 0x5a, 0xce, 0xed, 0x2d, 0xcf, 0x7e, 0x23, 0x87, 0xef, 0xa3, 0x6e,
	0xce, 0xcc, 0xdc, 0xba, 0xe4, 0x59, 0xfd, 0x04, 0xee, 0xa3, 0x8e, 0x02, 0x29, 0xde, 0xa5, 0x87,
	0xa4, 0xed, 0x79, 0xae, 0x44, 0x4c, 0x50, 0x5b, 0x52, 0x53, 0x90, 0x65, 0x2f, 0x69, 0x15, 0x1c,
	0xa2, 0x55, 0x05, 0x35, 0xd3, 0x4c, 0x70, 0xb2, 0xe2, 0x65, 0xe7, 0x6a, 0xc3, 0xa6, 0x52, 0xbe,
	0x6a, 0x7e, 0x4f, 0xc7, 0x67, 0x3b, 0x11, 0xef, 0x22, 0xa4, 0xa7, 0x3c, 0x3b, 0x36, 0xd4, 0x4c,
	0x34, 0x59, 0xf5, 0x2c, 0x9e, 0x8e, 0xdf, 0xa3, 0x75, 0x17, 0x29, 0x03, 0xe3, 0x7d, 0x43, 0xd6,
	0xc2, 0x60, 0xd0, 0x1d, 0x3d, 0x88, 0x67, 0x7b, 0x1a, 0xfb, 0x7b, 0x1a, 0xcb, 0xf3, 0xbc, 0x11,
	0x74, 0xdc, 0xec, 0x69, 0x5c, 0x0f, 0xe3, 0xb7, 0xac, 0x02, 0x07, 0x5d, 0xc4, 0xe0, 0x14, 0x6d,
	0x34, 0xc2, 0x4b, 0xc6, 0x99, 0x2e, 0x2c, 0x18, 0xfd, 0x2b, 0x38, 0xbd, 0x41, 0xc0, 0x11, 0xea,
	0x15, 0x40, 0x4b, 0x53, 0xb8, 0x99, 0xba, 0xcd, 0x4c, 0xe9, 0x82, 0x86, 0x77, 0xd1, 0xfa, 0x2c,
	0x3e, 0x02, 0xad, 0x69, 0x0e, 0xa4, 0x67, 0x4d, 0x8b, 0xe2, 0x08, 0xd0, 0xaa, 0xdd, 0x54, 0xc6,
	0x73, 0xfc, 0x01, 0xdd, 0xb2, 0x6d, 0xfb, 0x97, 0x65, 0x73, 0xbe, 0x6d, 0x9e, 0xba, 0xbd, 0xb1,
	0xa8, 0x46, 0xf7, 0x3e, 0x7d, 0xfb, 0xf9, 0xb9, 0x75, 0x07, 0x6f, 0xd9, 0x1b, 0x58, 0x0f, 0x13,
	0x6d, 0x14, 0xd0, 0xca, 0xbd, 0x23, 0x8f, 0x82, 0x83, 0xfd, 0x8b, 0xcb, 0x7e, 0xf0, 0xf5, 0xb2,
	0x1f, 0xfc, 0xb8, 0xec, 0x07, 0x1f, 0x1f, 0xff, 0xdd, 0x43, 0x92, 0x95, 0x0c, 0xb8, 0x71, 0x90,
	0x5f, 0x01, 0x00, 0x00, 0xff, 0xff, 0x8a, 0x78, 0xbb, 0x51, 0xa8, 0x04, 0x00, 0x00,
=======
	// 607 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x54, 0xcd, 0x6e, 0x13, 0x31,
	0x10, 0x66, 0xd3, 0xb4, 0x69, 0x9c, 0xb4, 0x20, 0xab, 0x05, 0xab, 0x82, 0x34, 0x8a, 0x2a, 0x14,
	0x21, 0xba, 0x4b, 0x0a, 0x48, 0x70, 0x6c, 0x25, 0x38, 0xb5, 0x05, 0x6d, 0x01, 0x09, 0x6e, 0xee,
	0xee, 0x74, 0xd7, 0xed, 0xae, 0x6d, 0xd9, 0xce, 0x4a, 0xbd, 0xf2, 0x0a, 0x3c, 0x03, 0x37, 0x1e,
	0xa4, 0x47, 0x24, 0xee, 0x08, 0x55, 0x3c, 0x08, 0x5a, 0xc7, 0x4d, 0x9d, 0xc0, 0x01, 0xb8, 0x79,
	0xbe, 0xf9, 0xbe, 0x6f, 0x3c, 0xe3, 0x1f, 0xb4, 0xa9, 0x41, 0x55, 0xa0, 0x22, 0x2a, 0x65, 0xc1,
	0x12, 0x6a, 0x98, 0xe0, 0x11, 0x54, 0xc0, 0x8d, 0x0e, 0xa5, 0x12, 0x46, 0xe0, 0x56, 0x06, 0x1c,
	0x14, 0x4b, 0x36, 0xf6, 0x33, 0x66, 0xf2, 0xf1, 0x71, 0x98, 0x88, 0x32, 0xa2, 0x2a, 0x13, 0x52,
	0x89, 0x53, 0xbb, 0xd8, 0x4e, 0xd2, 0xa8, 0xda, 0x89, 0xe4, 0x59, 0x16, 0x51, 0xc9, 0xf4, 0x8c,
	0x55, 0x35, 0xa2, 0x85, 0xcc, 0xe9, 0x28, 0xb2, 0x2e, 0xd4, 0x40, 0x3a, 0xb1, 0xdd, 0x78, 0x72,
	0xf6, 0x4c, 0x87, 0x4c, 0xd4, 0x8a, 0x92, 0x26, 0x39, 0xe3, 0xa0, 0xce, 0xaf, 0x2d, 0x4a, 0x30,
	0x34, 0xaa, 0x7e, 0x57, 0xad, 0x65, 0xc2, 0x16, 0x36, 0x22, 0xaa, 0x57, 0x0e, 0xbd, 0x9b, 0x09,
	0x91, 0x15, 0x50, 0x4b, 0x23, 0xca, 0xb9, 0x30, 0xb6, 0xb6, 0x6b, 0x60, 0xf0, 0x1c, 0x75, 0x5e,
	0xd4, 0x0d, 0x1d, 0x89, 0xb1, 0x4a, 0x00, 0x63, 0xd4, 0xe4, 0xb4, 0x04, 0x12, 0xf4, 0x1b, 0xc3,
	0x76, 0x6c, 0xd7, 0xf8, 0x36, 0x5a, 0x4a, 0x04, 0x3f, 0x61, 0x19, 0x69, 0xf4, 0x83, 0x61, 0x37,
	0x76, 0xd1, 0xe0, 0x29, 0x5a, 0xb4, 0xd2, 0x3f, 0x8a, 0x08, 0x6a, 0x49, 0x7a, 0x5e, 0x08, 0x9a,
	0x92, 0x46, 0xbf, 0x31, 0xec, 0xc6, 0x57, 0xe1, 0xe0, 0x73, 0x80, 0xba, 0x56, 0xf7, 0x7a, 0x02,
	0xe0, 0x43, 0xd4, 0x36, 0xac, 0x04, 0x6d, 0x68, 0x29, 0xad, 0x47, 0x67, 0xe7, 0x41, 0x38, 0x19,
	0x40, 0xe8, 0x0f, 0x20, 0x94, 0x67, 0x59, 0x0d, 0xe8, 0xb0, 0x1e, 0x40, 0x58, 0x8d, 0xc2, 0x37,
	0xac, 0x84, 0xbd, 0xe6, 0xc5, 0xf7, 0xcd, 0x1b, 0xf1, 0xb5, 0x45, 0xbd, 0x5f, 0x71, 0x7c, 0x0a,
	0x89, 0x71, 0x95, 0x5d, 0x84, 0xb7, 0xd1, 0x92, 0xb6, 0x5d, 0x92, 0x05, 0x5b, 0x64, 0x3d, 0x74,
	0x87, 0x17, 0xbe, 0xb2, 0x84, 0xc9, 0x08, 0x62, 0x47, 0x1a, 0x7c, 0x69, 0xa2, 0xae, 0x9f, 0xc0,
	0x21, 0xba, 0x99, 0x82, 0x66, 0x0a, 0xd2, 0x03, 0xca, 0xd9, 0x09, 0x68, 0x43, 0x82, 0x7e, 0x30,
	0x6c, 0xbb, 0x1d, 0xcc, 0x27, 0xf1, 0x43, 0xb4, 0x4a, 0x13, 0x33, 0xa6, 0xc5, 0x94, 0xde, 0xf0,
	0xe8, 0x73, 0x39, 0x7c, 0x1f, 0x75, 0x32, 0x66, 0xa6, 0xd4, 0x05, 0x8f, 0xea, 0x27, 0x70, 0x0f,
	0xb5, 0x14, 0x48, 0xf1, 0x36, 0xde, 0x27, 0x4d, 0x8f, 0x73, 0x05, 0x62, 0x82, 0x9a, 0x92, 0x9a,
	0x9c, 0x2c, 0x7a, 0x49, 0x8b, 0xe0, 0x3e, 0x5a, 0x56, 0x50, 0x31, 0xcd, 0x04, 0x27, 0x4b, 0x5e,
	0x76, 0x8a, 0xd6, 0xde, 0x54, 0xca, 0xc3, 0xfa, 0x2c, 0x5b, 0xbe, 0xb7, 0x03, 0xf1, 0x16, 0x42,
	0xfa, 0x9c, 0x27, 0x47, 0x86, 0x9a, 0xb1, 0x26, 0xcb, 0x1e, 0xc5, 0xc3, 0xf1, 0x3b, 0xb4, 0xe2,
	0x22, 0x65, 0x20, 0xdd, 0x35, 0xa4, 0xdd, 0x0f, 0xfe, 0xeb, 0x4c, 0x67, 0x6d, 0x70, 0x8c, 0x56,
	0x6b, 0xe0, 0x25, 0xe3, 0x4c, 0xe7, 0xd6, 0x18, 0xfd, 0xab, 0x71, 0x3c, 0xe7, 0x80, 0x07, 0xa8,
	0x9b, 0x03, 0x2d, 0x4c, 0xee, 0x7a, 0xea, 0xd4, 0x3d, 0xc5, 0x33, 0x18, 0xde, 0x42, 0x2b, 0x93,
	0xf8, 0x00, 0xb4, 0xa6, 0x19, 0x90, 0xae, 0x25, 0xcd, 0x82, 0x3b, 0x80, 0x96, 0xed, 0xad, 0x66,
	0x3c, 0xc3, 0xef, 0xd1, 0x2d, 0xbb, 0x6d, 0xff, 0x65, 0xad, 0x4d, 0x6f, 0x9b, 0x87, 0x6e, 0xac,
	0xce, 0xa2, 0x83, 0x7b, 0x1f, 0xbf, 0xfd, 0xfc, 0xd4, 0xb8, 0x83, 0xd7, 0xed, 0x73, 0xad, 0x46,
	0x91, 0x36, 0x0a, 0x68, 0xe9, 0x3e, 0x9d, 0x47, 0xc1, 0xde, 0xee, 0xc5, 0x65, 0x2f, 0xf8, 0x7a,
	0xd9, 0x0b, 0x7e, 0x5c, 0xf6, 0x82, 0x0f, 0x8f, 0xff, 0xee, 0xd7, 0x49, 0x0a, 0x06, 0xdc, 0x38,
	0x93, 0x5f, 0x01, 0x00, 0x00, 0xff, 0xff, 0xce, 0x95, 0xff, 0xb4, 0xd5, 0x04, 0x00, 0x00,
>>>>>>> d7c1eeaa8f49ce0d66164a03ba87bacc8accab5e
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// EventingClient is the client API for Eventing service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type EventingClient interface {
	StartEventSource(ctx context.Context, in *EventSource, opts ...grpc.CallOption) (Eventing_StartEventSourceClient, error)
}

type eventingClient struct {
	cc *grpc.ClientConn
}

func NewEventingClient(cc *grpc.ClientConn) EventingClient {
	return &eventingClient{cc}
}

func (c *eventingClient) StartEventSource(ctx context.Context, in *EventSource, opts ...grpc.CallOption) (Eventing_StartEventSourceClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Eventing_serviceDesc.Streams[0], "/generic.Eventing/StartEventSource", opts...)
	if err != nil {
		return nil, err
	}
	x := &eventingStartEventSourceClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Eventing_StartEventSourceClient interface {
	Recv() (*Event, error)
	grpc.ClientStream
}

type eventingStartEventSourceClient struct {
	grpc.ClientStream
}

func (x *eventingStartEventSourceClient) Recv() (*Event, error) {
	m := new(Event)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// EventingServer is the server API for Eventing service.
type EventingServer interface {
	StartEventSource(*EventSource, Eventing_StartEventSourceServer) error
}

// UnimplementedEventingServer can be embedded to have forward compatible implementations.
type UnimplementedEventingServer struct {
}

func (*UnimplementedEventingServer) StartEventSource(req *EventSource, srv Eventing_StartEventSourceServer) error {
	return status.Errorf(codes.Unimplemented, "method StartEventSource not implemented")
}

func RegisterEventingServer(s *grpc.Server, srv EventingServer) {
	s.RegisterService(&_Eventing_serviceDesc, srv)
}

func _Eventing_StartEventSource_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(EventSource)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(EventingServer).StartEventSource(m, &eventingStartEventSourceServer{stream})
}

type Eventing_StartEventSourceServer interface {
	Send(*Event) error
	grpc.ServerStream
}

type eventingStartEventSourceServer struct {
	grpc.ServerStream
}

func (x *eventingStartEventSourceServer) Send(m *Event) error {
	return x.ServerStream.SendMsg(m)
}

var _Eventing_serviceDesc = grpc.ServiceDesc{
	ServiceName: "generic.Eventing",
	HandlerType: (*EventingServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StartEventSource",
			Handler:       _Eventing_StartEventSource_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "server/application/events.proto",
}

func (m *EventSource) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventSource) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventSource) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Config != nil {
		i -= len(m.Config)
		copy(dAtA[i:], m.Config)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Config)))
		i--
		dAtA[i] = 0x12
	}
	if m.Name == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("name")
	} else {
		i -= len(*m.Name)
		copy(dAtA[i:], *m.Name)
		i = encodeVarintEvents(dAtA, i, uint64(len(*m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Event) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Event) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Event) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Payload == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("payload")
	} else {
		i -= len(m.Payload)
		copy(dAtA[i:], m.Payload)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Payload)))
		i--
		dAtA[i] = 0x12
	}
	if m.Name == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("name")
	} else {
		i -= len(*m.Name)
		copy(dAtA[i:], *m.Name)
		i = encodeVarintEvents(dAtA, i, uint64(len(*m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventPayload) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventPayload) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventPayload) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Source == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("source")
	} else {
		{
			size, err := m.Source.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Object == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("object")
	} else {
		i -= len(m.Object)
		copy(dAtA[i:], m.Object)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Object)))
		i--
		dAtA[i] = 0x12
<<<<<<< HEAD
	}
	i -= len(m.Timestamp)
	copy(dAtA[i:], m.Timestamp)
	i = encodeVarintEvents(dAtA, i, uint64(len(m.Timestamp)))
=======
	}
	{
		size, err := m.Timestamp.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintEvents(dAtA, i, uint64(size))
	}
>>>>>>> d7c1eeaa8f49ce0d66164a03ba87bacc8accab5e
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ObjectSource) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ObjectSource) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ObjectSource) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.HealthMessage != nil {
		i -= len(*m.HealthMessage)
		copy(dAtA[i:], *m.HealthMessage)
		i = encodeVarintEvents(dAtA, i, uint64(len(*m.HealthMessage)))
		i--
		dAtA[i] = 0x62
	}
	if m.HealthStatus != nil {
		i -= len(*m.HealthStatus)
		copy(dAtA[i:], *m.HealthStatus)
		i = encodeVarintEvents(dAtA, i, uint64(len(*m.HealthStatus)))
		i--
		dAtA[i] = 0x5a
	}
	if m.SyncFinishedAt != nil {
		{
			size, err := m.SyncFinishedAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	{
		size, err := m.SyncStartedAt.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x4a
	i -= len(m.SyncStatus)
	copy(dAtA[i:], m.SyncStatus)
	i = encodeVarintEvents(dAtA, i, uint64(len(m.SyncStatus)))
	i--
	dAtA[i] = 0x42
	i -= len(m.AppName)
	copy(dAtA[i:], m.AppName)
	i = encodeVarintEvents(dAtA, i, uint64(len(m.AppName)))
	i--
	dAtA[i] = 0x3a
	i -= len(m.Revision)
	copy(dAtA[i:], m.Revision)
	i = encodeVarintEvents(dAtA, i, uint64(len(m.Revision)))
	i--
	dAtA[i] = 0x32
	i -= len(m.Path)
	copy(dAtA[i:], m.Path)
	i = encodeVarintEvents(dAtA, i, uint64(len(m.Path)))
	i--
	dAtA[i] = 0x2a
	i -= len(m.RepoURL)
	copy(dAtA[i:], m.RepoURL)
	i = encodeVarintEvents(dAtA, i, uint64(len(m.RepoURL)))
	i--
	dAtA[i] = 0x22
	i -= len(m.GitManifest)
	copy(dAtA[i:], m.GitManifest)
	i = encodeVarintEvents(dAtA, i, uint64(len(m.GitManifest)))
	i--
	dAtA[i] = 0x1a
	i -= len(m.ActualManifest)
	copy(dAtA[i:], m.ActualManifest)
	i = encodeVarintEvents(dAtA, i, uint64(len(m.ActualManifest)))
	i--
	dAtA[i] = 0x12
	i -= len(m.DesiredManifest)
	copy(dAtA[i:], m.DesiredManifest)
	i = encodeVarintEvents(dAtA, i, uint64(len(m.DesiredManifest)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func encodeVarintEvents(dAtA []byte, offset int, v uint64) int {
	offset -= sovEvents(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *EventSource) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Name != nil {
		l = len(*m.Name)
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.Config != nil {
		l = len(m.Config)
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Event) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Name != nil {
		l = len(*m.Name)
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.Payload != nil {
		l = len(m.Payload)
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EventPayload) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
<<<<<<< HEAD
	l = len(m.Timestamp)
=======
	l = m.Timestamp.Size()
>>>>>>> d7c1eeaa8f49ce0d66164a03ba87bacc8accab5e
	n += 1 + l + sovEvents(uint64(l))
	if m.Object != nil {
		l = len(m.Object)
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.Source != nil {
		l = m.Source.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ObjectSource) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DesiredManifest)
	n += 1 + l + sovEvents(uint64(l))
	l = len(m.ActualManifest)
	n += 1 + l + sovEvents(uint64(l))
	l = len(m.GitManifest)
	n += 1 + l + sovEvents(uint64(l))
	l = len(m.RepoURL)
	n += 1 + l + sovEvents(uint64(l))
	l = len(m.Path)
	n += 1 + l + sovEvents(uint64(l))
	l = len(m.Revision)
	n += 1 + l + sovEvents(uint64(l))
	l = len(m.AppName)
	n += 1 + l + sovEvents(uint64(l))
	l = len(m.SyncStatus)
	n += 1 + l + sovEvents(uint64(l))
	l = m.SyncStartedAt.Size()
	n += 1 + l + sovEvents(uint64(l))
	if m.SyncFinishedAt != nil {
		l = m.SyncFinishedAt.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.HealthStatus != nil {
		l = len(*m.HealthStatus)
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.HealthMessage != nil {
		l = len(*m.HealthMessage)
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovEvents(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozEvents(x uint64) (n int) {
	return sovEvents(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *EventSource) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventSource: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventSource: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Name = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Config = append(m.Config[:0], dAtA[iNdEx:postIndex]...)
			if m.Config == nil {
				m.Config = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("name")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Event) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Event: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Event: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Name = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload[:0], dAtA[iNdEx:postIndex]...)
			if m.Payload == nil {
				m.Payload = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("name")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("payload")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventPayload) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventPayload: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventPayload: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
<<<<<<< HEAD
			var stringLen uint64
=======
			var msglen int
>>>>>>> d7c1eeaa8f49ce0d66164a03ba87bacc8accab5e
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
<<<<<<< HEAD
				stringLen |= uint64(b&0x7F) << shift
=======
				msglen |= int(b&0x7F) << shift
>>>>>>> d7c1eeaa8f49ce0d66164a03ba87bacc8accab5e
				if b < 0x80 {
					break
				}
			}
<<<<<<< HEAD
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
=======
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
>>>>>>> d7c1eeaa8f49ce0d66164a03ba87bacc8accab5e
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
<<<<<<< HEAD
			m.Timestamp = string(dAtA[iNdEx:postIndex])
=======
			if err := m.Timestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
>>>>>>> d7c1eeaa8f49ce0d66164a03ba87bacc8accab5e
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Object", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Object = append(m.Object[:0], dAtA[iNdEx:postIndex]...)
			if m.Object == nil {
				m.Object = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Source == nil {
				m.Source = &ObjectSource{}
			}
			if err := m.Source.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000004)
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("timestamp")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("object")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("source")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ObjectSource) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ObjectSource: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ObjectSource: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DesiredManifest", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DesiredManifest = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActualManifest", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ActualManifest = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GitManifest", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GitManifest = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepoURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RepoURL = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Revision", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Revision = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SyncStatus", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SyncStatus = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SyncStartedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SyncStartedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SyncFinishedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SyncFinishedAt == nil {
				m.SyncFinishedAt = &v1.Time{}
			}
			if err := m.SyncFinishedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HealthStatus", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.HealthStatus = &s
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HealthMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.HealthMessage = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipEvents(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthEvents
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupEvents
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthEvents
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthEvents        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowEvents          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupEvents = fmt.Errorf("proto: unexpected end of group")
)
