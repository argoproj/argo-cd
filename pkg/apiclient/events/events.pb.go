// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: server/application/events.proto

// Events Service
//
// Events Service API provides a generic event-source that allows
// listening for argo-cd events natively from argo-events.

package events

import (
	context "context"
	fmt "fmt"
	_ "github.com/argoproj/argo-cd/v2/pkg/apis/application/v1alpha1"
	_ "github.com/gogo/protobuf/gogoproto"
	github_com_gogo_protobuf_proto "github.com/gogo/protobuf/proto"
	proto "github.com/gogo/protobuf/proto"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type EventSource struct {
	// The event source name.
	Name *string `protobuf:"bytes,1,req,name=name" json:"name,omitempty"`
	// The event source configuration value.
	Config               []byte   `protobuf:"bytes,2,opt,name=config" json:"config,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EventSource) Reset()         { *m = EventSource{} }
func (m *EventSource) String() string { return proto.CompactTextString(m) }
func (*EventSource) ProtoMessage()    {}
func (*EventSource) Descriptor() ([]byte, []int) {
	return fileDescriptor_3ad9267ec62b112f, []int{0}
}
func (m *EventSource) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventSource) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventSource.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventSource) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventSource.Merge(m, src)
}
func (m *EventSource) XXX_Size() int {
	return m.Size()
}
func (m *EventSource) XXX_DiscardUnknown() {
	xxx_messageInfo_EventSource.DiscardUnknown(m)
}

var xxx_messageInfo_EventSource proto.InternalMessageInfo

func (m *EventSource) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *EventSource) GetConfig() []byte {
	if m != nil {
		return m.Config
	}
	return nil
}

// *
// Represents an event
type Event struct {
	// The event source name.
	Name *string `protobuf:"bytes,1,req,name=name" json:"name,omitempty"`
	// The event payload.
	Payload              []byte   `protobuf:"bytes,2,req,name=payload" json:"payload,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Event) Reset()         { *m = Event{} }
func (m *Event) String() string { return proto.CompactTextString(m) }
func (*Event) ProtoMessage()    {}
func (*Event) Descriptor() ([]byte, []int) {
	return fileDescriptor_3ad9267ec62b112f, []int{1}
}
func (m *Event) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Event) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Event.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Event) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Event.Merge(m, src)
}
func (m *Event) XXX_Size() int {
	return m.Size()
}
func (m *Event) XXX_DiscardUnknown() {
	xxx_messageInfo_Event.DiscardUnknown(m)
}

var xxx_messageInfo_Event proto.InternalMessageInfo

func (m *Event) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *Event) GetPayload() []byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

// *
// The actual object that will be send
// with each event.
type EventPayload struct {
	// The timestamp of the event
	Timestamp string `protobuf:"bytes,1,req,name=timestamp" json:"timestamp"`
	// The object that the event is about
	Object []byte `protobuf:"bytes,2,req,name=object" json:"object,omitempty"`
	// The object source information
	Source *ObjectSource `protobuf:"bytes,3,req,name=source" json:"source,omitempty"`
	// The errors of this object
	Errors []*ObjectError `protobuf:"bytes,4,rep,name=errors" json:"errors,omitempty"`
	// A version of the application and its dependencies
	AppVersions          *ApplicationVersions `protobuf:"bytes,5,opt,name=appVersions" json:"appVersions,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *EventPayload) Reset()         { *m = EventPayload{} }
func (m *EventPayload) String() string { return proto.CompactTextString(m) }
func (*EventPayload) ProtoMessage()    {}
func (*EventPayload) Descriptor() ([]byte, []int) {
	return fileDescriptor_3ad9267ec62b112f, []int{2}
}
func (m *EventPayload) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventPayload) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventPayload.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventPayload) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventPayload.Merge(m, src)
}
func (m *EventPayload) XXX_Size() int {
	return m.Size()
}
func (m *EventPayload) XXX_DiscardUnknown() {
	xxx_messageInfo_EventPayload.DiscardUnknown(m)
}

var xxx_messageInfo_EventPayload proto.InternalMessageInfo

func (m *EventPayload) GetTimestamp() string {
	if m != nil {
		return m.Timestamp
	}
	return ""
}

func (m *EventPayload) GetObject() []byte {
	if m != nil {
		return m.Object
	}
	return nil
}

func (m *EventPayload) GetSource() *ObjectSource {
	if m != nil {
		return m.Source
	}
	return nil
}

func (m *EventPayload) GetErrors() []*ObjectError {
	if m != nil {
		return m.Errors
	}
	return nil
}

func (m *EventPayload) GetAppVersions() *ApplicationVersions {
	if m != nil {
		return m.AppVersions
	}
	return nil
}

// *
// Holds information about the object source
type ObjectSource struct {
	DesiredManifest       string            `protobuf:"bytes,1,opt,name=desiredManifest" json:"desiredManifest"`
	ActualManifest        string            `protobuf:"bytes,2,opt,name=actualManifest" json:"actualManifest"`
	GitManifest           string            `protobuf:"bytes,3,opt,name=gitManifest" json:"gitManifest"`
	RepoURL               string            `protobuf:"bytes,4,opt,name=repoURL" json:"repoURL"`
	Path                  string            `protobuf:"bytes,5,opt,name=path" json:"path"`
	Revision              string            `protobuf:"bytes,6,opt,name=revision" json:"revision"`
	CommitMessage         string            `protobuf:"bytes,7,opt,name=commitMessage" json:"commitMessage"`
	CommitAuthor          string            `protobuf:"bytes,8,opt,name=commitAuthor" json:"commitAuthor"`
	CommitDate            *v1.Time          `protobuf:"bytes,9,opt,name=commitDate" json:"commitDate,omitempty"`
	AppName               string            `protobuf:"bytes,10,opt,name=appName" json:"appName"`
	AppLabels             map[string]string `protobuf:"bytes,11,rep,name=appLabels" json:"appLabels" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	SyncStatus            string            `protobuf:"bytes,12,opt,name=syncStatus" json:"syncStatus"`
	SyncStartedAt         v1.Time           `protobuf:"bytes,13,opt,name=syncStartedAt" json:"syncStartedAt"`
	SyncFinishedAt        *v1.Time          `protobuf:"bytes,14,opt,name=syncFinishedAt" json:"syncFinishedAt,omitempty"`
	HealthStatus          *string           `protobuf:"bytes,15,opt,name=healthStatus" json:"healthStatus,omitempty"`
	HealthMessage         *string           `protobuf:"bytes,16,opt,name=healthMessage" json:"healthMessage,omitempty"`
	Cluster               string            `protobuf:"bytes,17,opt,name=cluster" json:"cluster"`
	HistoryId             int64             `protobuf:"varint,18,opt,name=historyId" json:"historyId"`
	OperationSyncRevision string            `protobuf:"bytes,19,opt,name=operationSyncRevision" json:"operationSyncRevision"`
	AppUID                string            `protobuf:"bytes,20,opt,name=appUID" json:"appUID"`
	AppNamespace          string            `protobuf:"bytes,21,opt,name=appNamespace" json:"appNamespace"`
	AppInstanceLabelKey   string            `protobuf:"bytes,22,opt,name=appInstanceLabelKey" json:"appInstanceLabelKey"`
	TrackingMethod        string            `protobuf:"bytes,23,opt,name=trackingMethod" json:"trackingMethod"`
	XXX_NoUnkeyedLiteral  struct{}          `json:"-"`
	XXX_unrecognized      []byte            `json:"-"`
	XXX_sizecache         int32             `json:"-"`
}

func (m *ObjectSource) Reset()         { *m = ObjectSource{} }
func (m *ObjectSource) String() string { return proto.CompactTextString(m) }
func (*ObjectSource) ProtoMessage()    {}
func (*ObjectSource) Descriptor() ([]byte, []int) {
	return fileDescriptor_3ad9267ec62b112f, []int{3}
}
func (m *ObjectSource) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ObjectSource) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ObjectSource.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ObjectSource) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ObjectSource.Merge(m, src)
}
func (m *ObjectSource) XXX_Size() int {
	return m.Size()
}
func (m *ObjectSource) XXX_DiscardUnknown() {
	xxx_messageInfo_ObjectSource.DiscardUnknown(m)
}

var xxx_messageInfo_ObjectSource proto.InternalMessageInfo

func (m *ObjectSource) GetDesiredManifest() string {
	if m != nil {
		return m.DesiredManifest
	}
	return ""
}

func (m *ObjectSource) GetActualManifest() string {
	if m != nil {
		return m.ActualManifest
	}
	return ""
}

func (m *ObjectSource) GetGitManifest() string {
	if m != nil {
		return m.GitManifest
	}
	return ""
}

func (m *ObjectSource) GetRepoURL() string {
	if m != nil {
		return m.RepoURL
	}
	return ""
}

func (m *ObjectSource) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *ObjectSource) GetRevision() string {
	if m != nil {
		return m.Revision
	}
	return ""
}

func (m *ObjectSource) GetCommitMessage() string {
	if m != nil {
		return m.CommitMessage
	}
	return ""
}

func (m *ObjectSource) GetCommitAuthor() string {
	if m != nil {
		return m.CommitAuthor
	}
	return ""
}

func (m *ObjectSource) GetCommitDate() *v1.Time {
	if m != nil {
		return m.CommitDate
	}
	return nil
}

func (m *ObjectSource) GetAppName() string {
	if m != nil {
		return m.AppName
	}
	return ""
}

func (m *ObjectSource) GetAppLabels() map[string]string {
	if m != nil {
		return m.AppLabels
	}
	return nil
}

func (m *ObjectSource) GetSyncStatus() string {
	if m != nil {
		return m.SyncStatus
	}
	return ""
}

func (m *ObjectSource) GetSyncStartedAt() v1.Time {
	if m != nil {
		return m.SyncStartedAt
	}
	return v1.Time{}
}

func (m *ObjectSource) GetSyncFinishedAt() *v1.Time {
	if m != nil {
		return m.SyncFinishedAt
	}
	return nil
}

func (m *ObjectSource) GetHealthStatus() string {
	if m != nil && m.HealthStatus != nil {
		return *m.HealthStatus
	}
	return ""
}

func (m *ObjectSource) GetHealthMessage() string {
	if m != nil && m.HealthMessage != nil {
		return *m.HealthMessage
	}
	return ""
}

func (m *ObjectSource) GetCluster() string {
	if m != nil {
		return m.Cluster
	}
	return ""
}

func (m *ObjectSource) GetHistoryId() int64 {
	if m != nil {
		return m.HistoryId
	}
	return 0
}

func (m *ObjectSource) GetOperationSyncRevision() string {
	if m != nil {
		return m.OperationSyncRevision
	}
	return ""
}

func (m *ObjectSource) GetAppUID() string {
	if m != nil {
		return m.AppUID
	}
	return ""
}

func (m *ObjectSource) GetAppNamespace() string {
	if m != nil {
		return m.AppNamespace
	}
	return ""
}

func (m *ObjectSource) GetAppInstanceLabelKey() string {
	if m != nil {
		return m.AppInstanceLabelKey
	}
	return ""
}

func (m *ObjectSource) GetTrackingMethod() string {
	if m != nil {
		return m.TrackingMethod
	}
	return ""
}

// *
// Holds error information
type ObjectError struct {
	Type                 string   `protobuf:"bytes,1,opt,name=type" json:"type"`
	Level                string   `protobuf:"bytes,2,opt,name=level" json:"level"`
	Message              string   `protobuf:"bytes,3,opt,name=message" json:"message"`
	LastSeen             v1.Time  `protobuf:"bytes,4,opt,name=lastSeen" json:"lastSeen"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ObjectError) Reset()         { *m = ObjectError{} }
func (m *ObjectError) String() string { return proto.CompactTextString(m) }
func (*ObjectError) ProtoMessage()    {}
func (*ObjectError) Descriptor() ([]byte, []int) {
	return fileDescriptor_3ad9267ec62b112f, []int{4}
}
func (m *ObjectError) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ObjectError) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ObjectError.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ObjectError) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ObjectError.Merge(m, src)
}
func (m *ObjectError) XXX_Size() int {
	return m.Size()
}
func (m *ObjectError) XXX_DiscardUnknown() {
	xxx_messageInfo_ObjectError.DiscardUnknown(m)
}

var xxx_messageInfo_ObjectError proto.InternalMessageInfo

func (m *ObjectError) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *ObjectError) GetLevel() string {
	if m != nil {
		return m.Level
	}
	return ""
}

func (m *ObjectError) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *ObjectError) GetLastSeen() v1.Time {
	if m != nil {
		return m.LastSeen
	}
	return v1.Time{}
}

type Dependencies struct {
	// Content of Chart.lock
	Lock *string `protobuf:"bytes,1,opt,name=lock" json:"lock,omitempty"`
	// Content of Cart.yaml/dependencies
	Deps *string `protobuf:"bytes,2,opt,name=deps" json:"deps,omitempty"`
	// Content of requirements.yaml
	Requirements         *string  `protobuf:"bytes,3,opt,name=requirements" json:"requirements,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Dependencies) Reset()         { *m = Dependencies{} }
func (m *Dependencies) String() string { return proto.CompactTextString(m) }
func (*Dependencies) ProtoMessage()    {}
func (*Dependencies) Descriptor() ([]byte, []int) {
	return fileDescriptor_3ad9267ec62b112f, []int{5}
}
func (m *Dependencies) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Dependencies) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Dependencies.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Dependencies) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Dependencies.Merge(m, src)
}
func (m *Dependencies) XXX_Size() int {
	return m.Size()
}
func (m *Dependencies) XXX_DiscardUnknown() {
	xxx_messageInfo_Dependencies.DiscardUnknown(m)
}

var xxx_messageInfo_Dependencies proto.InternalMessageInfo

func (m *Dependencies) GetLock() string {
	if m != nil && m.Lock != nil {
		return *m.Lock
	}
	return ""
}

func (m *Dependencies) GetDeps() string {
	if m != nil && m.Deps != nil {
		return *m.Deps
	}
	return ""
}

func (m *Dependencies) GetRequirements() string {
	if m != nil && m.Requirements != nil {
		return *m.Requirements
	}
	return ""
}

type ApplicationVersions struct {
	// Application version presented by single value
	AppVersion *string `protobuf:"bytes,1,opt,name=appVersion" json:"appVersion,omitempty"`
	// Yaml content of dependencies
	Dependencies         *Dependencies `protobuf:"bytes,2,opt,name=dependencies" json:"dependencies,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *ApplicationVersions) Reset()         { *m = ApplicationVersions{} }
func (m *ApplicationVersions) String() string { return proto.CompactTextString(m) }
func (*ApplicationVersions) ProtoMessage()    {}
func (*ApplicationVersions) Descriptor() ([]byte, []int) {
	return fileDescriptor_3ad9267ec62b112f, []int{6}
}
func (m *ApplicationVersions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ApplicationVersions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ApplicationVersions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ApplicationVersions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ApplicationVersions.Merge(m, src)
}
func (m *ApplicationVersions) XXX_Size() int {
	return m.Size()
}
func (m *ApplicationVersions) XXX_DiscardUnknown() {
	xxx_messageInfo_ApplicationVersions.DiscardUnknown(m)
}

var xxx_messageInfo_ApplicationVersions proto.InternalMessageInfo

func (m *ApplicationVersions) GetAppVersion() string {
	if m != nil && m.AppVersion != nil {
		return *m.AppVersion
	}
	return ""
}

func (m *ApplicationVersions) GetDependencies() *Dependencies {
	if m != nil {
		return m.Dependencies
	}
	return nil
}

func init() {
	proto.RegisterType((*EventSource)(nil), "generic.EventSource")
	proto.RegisterType((*Event)(nil), "generic.Event")
	proto.RegisterType((*EventPayload)(nil), "generic.EventPayload")
	proto.RegisterType((*ObjectSource)(nil), "generic.ObjectSource")
	proto.RegisterMapType((map[string]string)(nil), "generic.ObjectSource.AppLabelsEntry")
	proto.RegisterType((*ObjectError)(nil), "generic.ObjectError")
	proto.RegisterType((*Dependencies)(nil), "generic.Dependencies")
	proto.RegisterType((*ApplicationVersions)(nil), "generic.ApplicationVersions")
}

func init() { proto.RegisterFile("server/application/events.proto", fileDescriptor_3ad9267ec62b112f) }

var fileDescriptor_3ad9267ec62b112f = []byte{
	// 1009 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x56, 0xdd, 0x6e, 0x1c, 0xb5,
	0x17, 0xff, 0xcf, 0xe6, 0xfb, 0xec, 0x26, 0xed, 0xdf, 0x49, 0x5a, 0x2b, 0x0a, 0xe9, 0x6a, 0x15,
	0xa1, 0x55, 0xd5, 0xce, 0x92, 0xf0, 0xa1, 0xb6, 0x42, 0x48, 0xa9, 0x12, 0x44, 0x20, 0x01, 0x34,
	0xa1, 0x95, 0xe8, 0x9d, 0x33, 0x73, 0x3a, 0xeb, 0xee, 0x8c, 0x6d, 0x6c, 0xef, 0x4a, 0x7b, 0x8b,
	0x78, 0x03, 0x9e, 0x84, 0xb7, 0xe8, 0x25, 0x12, 0xf7, 0x08, 0x45, 0x48, 0xbc, 0x06, 0xb2, 0x67,
	0x76, 0xe3, 0x09, 0xb9, 0xa0, 0xdc, 0xf9, 0xfc, 0xce, 0xef, 0x1c, 0xfb, 0xcc, 0xf9, 0x1a, 0x78,
	0x60, 0x50, 0x4f, 0x50, 0x0f, 0x98, 0x52, 0x05, 0x4f, 0x99, 0xe5, 0x52, 0x0c, 0x70, 0x82, 0xc2,
	0x9a, 0x58, 0x69, 0x69, 0x25, 0x59, 0xc9, 0x51, 0xa0, 0xe6, 0xe9, 0xce, 0x59, 0xce, 0xed, 0x70,
	0x7c, 0x19, 0xa7, 0xb2, 0x1c, 0x30, 0x9d, 0x4b, 0xa5, 0xe5, 0x1b, 0x7f, 0x78, 0x9c, 0x66, 0x83,
	0xc9, 0xe1, 0x40, 0x8d, 0xf2, 0x01, 0x53, 0xdc, 0x34, 0x5c, 0x4d, 0x0e, 0x58, 0xa1, 0x86, 0xec,
	0x60, 0xe0, 0xbd, 0x30, 0x8b, 0x59, 0xe5, 0x76, 0xe7, 0xa3, 0xd1, 0x13, 0x13, 0x73, 0xe9, 0x2c,
	0x4a, 0x96, 0x0e, 0xb9, 0x40, 0x3d, 0xbd, 0x76, 0x51, 0xa2, 0x65, 0x83, 0xc9, 0x3f, 0xad, 0xb6,
	0x72, 0xe9, 0x2f, 0xb6, 0x72, 0xe0, 0x4e, 0x35, 0xba, 0x9b, 0x4b, 0x99, 0x17, 0xe8, 0x4c, 0x07,
	0x4c, 0x08, 0x69, 0xfd, 0xdd, 0x75, 0x00, 0xbd, 0xa7, 0xd0, 0x3e, 0x71, 0x01, 0x5d, 0xc8, 0xb1,
	0x4e, 0x91, 0x10, 0x58, 0x14, 0xac, 0x44, 0x1a, 0x75, 0x5b, 0xfd, 0xb5, 0xc4, 0x9f, 0xc9, 0x3d,
	0x58, 0x4e, 0xa5, 0x78, 0xcd, 0x73, 0xda, 0xea, 0x46, 0xfd, 0x4e, 0x52, 0x4b, 0xbd, 0x8f, 0x61,
	0xc9, 0x9b, 0xde, 0x6a, 0x44, 0x61, 0x45, 0xb1, 0x69, 0x21, 0x59, 0x46, 0x5b, 0xdd, 0x56, 0xbf,
	0x93, 0xcc, 0xc4, 0xde, 0x5f, 0x11, 0x74, 0xbc, 0xdd, 0xb7, 0x15, 0x40, 0x7a, 0xb0, 0x66, 0x79,
	0x89, 0xc6, 0xb2, 0x52, 0x55, 0x3e, 0x9e, 0x2f, 0xbe, 0xfd, 0xfd, 0xc1, 0xff, 0x92, 0x6b, 0xd8,
	0xbd, 0x41, 0x5e, 0xbe, 0xc1, 0xd4, 0xd6, 0xde, 0x6a, 0x89, 0x3c, 0x86, 0x65, 0xe3, 0x5f, 0x4e,
	0x17, 0xba, 0xad, 0x7e, 0xfb, 0x70, 0x3b, 0xae, 0x13, 0x12, 0x7f, 0xe3, 0x09, 0x55, 0x58, 0x49,
	0x4d, 0x22, 0x8f, 0x60, 0x19, 0xb5, 0x96, 0xda, 0xd0, 0xc5, 0xee, 0x42, 0xbf, 0x7d, 0xb8, 0x75,
	0x83, 0x7e, 0xe2, 0x94, 0x49, 0xcd, 0x21, 0x9f, 0x41, 0x9b, 0x29, 0xf5, 0x12, 0xb5, 0x71, 0x1f,
	0x8c, 0x2e, 0x75, 0xa3, 0x7e, 0xfb, 0x70, 0x77, 0x6e, 0x72, 0x74, 0x9d, 0xc9, 0x19, 0x27, 0x09,
	0x0d, 0x7a, 0x3f, 0xad, 0x41, 0x27, 0x7c, 0x06, 0x89, 0xe1, 0x4e, 0x86, 0x86, 0x6b, 0xcc, 0xce,
	0x99, 0xe0, 0xaf, 0xd1, 0x58, 0x1a, 0x75, 0xa3, 0x79, 0xbc, 0x37, 0x95, 0xe4, 0x11, 0x6c, 0xb0,
	0xd4, 0x8e, 0x59, 0x31, 0xa7, 0xb7, 0x02, 0xfa, 0x0d, 0x1d, 0x79, 0x1f, 0xda, 0x39, 0xb7, 0x73,
	0xea, 0x42, 0x40, 0x0d, 0x15, 0x64, 0x0f, 0x56, 0x34, 0x2a, 0xf9, 0x22, 0x39, 0xa3, 0x8b, 0x01,
	0x67, 0x06, 0x12, 0x0a, 0x8b, 0x8a, 0xd9, 0xa1, 0x8f, 0x77, 0xa6, 0xf4, 0x08, 0xe9, 0xc2, 0xaa,
	0xc6, 0x09, 0x77, 0xd1, 0xd1, 0xe5, 0x40, 0x3b, 0x47, 0xc9, 0x43, 0x58, 0x4f, 0x65, 0x59, 0x72,
	0x7b, 0x8e, 0xc6, 0xb0, 0x1c, 0xe9, 0x4a, 0x40, 0x6b, 0xaa, 0x48, 0x1f, 0x3a, 0x15, 0x70, 0x34,
	0xb6, 0x43, 0xa9, 0xe9, 0x6a, 0x40, 0x6d, 0x68, 0xc8, 0x97, 0x00, 0x95, 0x7c, 0xcc, 0x2c, 0xd2,
	0x35, 0x9f, 0x87, 0x87, 0x71, 0xd5, 0x23, 0x71, 0xd8, 0x23, 0xb1, 0x1a, 0xe5, 0x0e, 0x30, 0xb1,
	0xeb, 0x91, 0x78, 0x72, 0x10, 0x7f, 0xc7, 0x4b, 0x4c, 0x02, 0x6b, 0x17, 0x3d, 0x53, 0xea, 0x6b,
	0x57, 0xaf, 0x10, 0x46, 0x5f, 0x83, 0xe4, 0x0b, 0x58, 0x63, 0x4a, 0x9d, 0xb1, 0x4b, 0x2c, 0x0c,
	0x6d, 0xfb, 0x2a, 0xd9, 0xbf, 0xb5, 0xa8, 0x5c, 0xfe, 0x2b, 0xda, 0x89, 0xb0, 0x7a, 0x3a, 0xab,
	0xd9, 0xb9, 0x31, 0xd9, 0x07, 0x30, 0x53, 0x91, 0x5e, 0x58, 0x66, 0xc7, 0x86, 0x76, 0x82, 0xcb,
	0x02, 0x9c, 0xbc, 0x84, 0xf5, 0x5a, 0xd2, 0x16, 0xb3, 0x23, 0x4b, 0xd7, 0xdf, 0x35, 0xbc, 0xd9,
	0xd7, 0x6d, 0xb8, 0x21, 0x09, 0x6c, 0x38, 0xe0, 0x73, 0x2e, 0xb8, 0x19, 0x7a, 0xc7, 0x1b, 0xef,
	0xfc, 0xdd, 0x6e, 0x78, 0x20, 0x3d, 0xe8, 0x0c, 0x91, 0x15, 0x76, 0x58, 0xc7, 0x74, 0xc7, 0xc5,
	0x94, 0x34, 0x30, 0xb2, 0x0f, 0xeb, 0x95, 0x3c, 0xab, 0x80, 0xbb, 0x9e, 0xd4, 0x04, 0x5d, 0x16,
	0xd2, 0x62, 0x6c, 0x2c, 0x6a, 0xfa, 0xff, 0x30, 0x0b, 0x35, 0xe8, 0x66, 0xc2, 0x90, 0x1b, 0x2b,
	0xf5, 0xf4, 0x34, 0xa3, 0xa4, 0x1b, 0xf5, 0x17, 0x66, 0xdf, 0x77, 0x0e, 0x93, 0x67, 0xb0, 0x2d,
	0x95, 0x1b, 0x80, 0x5c, 0x8a, 0x8b, 0xa9, 0x48, 0x93, 0x59, 0x69, 0x6e, 0x06, 0x1e, 0x6f, 0xa7,
	0x90, 0x5d, 0x58, 0x66, 0x4a, 0xbd, 0x38, 0x3d, 0xa6, 0x5b, 0x01, 0xb9, 0xc6, 0x5c, 0x65, 0xd6,
	0xe5, 0x60, 0x14, 0x4b, 0x91, 0x6e, 0x87, 0x95, 0x19, 0x6a, 0xc8, 0x27, 0xb0, 0xc9, 0x94, 0x3a,
	0x15, 0xc6, 0x32, 0x91, 0xa2, 0x4f, 0xfc, 0x57, 0x38, 0xa5, 0xf7, 0x02, 0x83, 0xdb, 0x08, 0xae,
	0xb3, 0xad, 0x66, 0xe9, 0x88, 0x8b, 0xfc, 0x1c, 0xed, 0x50, 0x66, 0xf4, 0x7e, 0xd8, 0xd9, 0x4d,
	0xdd, 0xce, 0xa7, 0xb0, 0xd1, 0x2c, 0x36, 0x72, 0x17, 0x16, 0x46, 0x38, 0xad, 0xa6, 0x47, 0xe2,
	0x8e, 0x64, 0x0b, 0x96, 0x26, 0xac, 0x18, 0x63, 0x35, 0x22, 0x92, 0x4a, 0x78, 0xd6, 0x7a, 0x12,
	0xf5, 0x7e, 0x89, 0xa0, 0x1d, 0x8c, 0x37, 0xd7, 0xdf, 0x76, 0xaa, 0xb0, 0x31, 0x7a, 0x3c, 0x42,
	0x76, 0x60, 0xa9, 0xc0, 0x09, 0x16, 0x8d, 0x31, 0x53, 0x41, 0x2e, 0x63, 0x65, 0x9d, 0xd1, 0x70,
	0xb2, 0xcc, 0x40, 0x72, 0x06, 0xab, 0x05, 0x33, 0xf6, 0x02, 0x51, 0xf8, 0xb1, 0xf2, 0x5f, 0x4a,
	0x78, 0xee, 0xa1, 0xf7, 0x0a, 0x3a, 0xc7, 0xa8, 0x50, 0x64, 0x28, 0x52, 0x8e, 0xc6, 0xad, 0x98,
	0x42, 0xa6, 0xa3, 0x3a, 0x60, 0x7f, 0x76, 0x58, 0x86, 0xca, 0xd4, 0x01, 0xfb, 0xb3, 0xab, 0x50,
	0x8d, 0x3f, 0x8c, 0xb9, 0xc6, 0xd2, 0x6d, 0xe9, 0xea, 0xa9, 0x49, 0x03, 0xeb, 0x29, 0xd8, 0xbc,
	0x65, 0x74, 0x93, 0x3d, 0x80, 0xeb, 0xe1, 0x5d, 0x5f, 0x14, 0x20, 0xe4, 0x29, 0x74, 0xb2, 0xe0,
	0x49, 0xfe, 0xda, 0x70, 0xe1, 0x84, 0xef, 0x4d, 0x1a, 0xd4, 0x43, 0x84, 0x55, 0xbf, 0xf1, 0xb8,
	0xc8, 0xc9, 0xf7, 0x70, 0xd7, 0x37, 0x69, 0xb8, 0x75, 0xaf, 0xd7, 0x50, 0x80, 0xee, 0x6c, 0x34,
	0xd1, 0xde, 0x7b, 0x3f, 0xfe, 0xf6, 0xe7, 0xcf, 0xad, 0xfb, 0x64, 0xdb, 0xaf, 0xf2, 0xc9, 0xc1,
	0xc0, 0x58, 0x8d, 0xac, 0xac, 0x7f, 0x48, 0x3e, 0x88, 0x9e, 0x1f, 0xbd, 0xbd, 0xda, 0x8b, 0x7e,
	0xbd, 0xda, 0x8b, 0xfe, 0xb8, 0xda, 0x8b, 0x5e, 0x7d, 0xf8, 0xef, 0xfe, 0x48, 0xd2, 0x82, 0xa3,
	0xb0, 0xb5, 0x93, 0xbf, 0x03, 0x00, 0x00, 0xff, 0xff, 0xc3, 0x5b, 0xa5, 0x9e, 0xf1, 0x08, 0x00,
	0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// EventingClient is the client API for Eventing service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type EventingClient interface {
	StartEventSource(ctx context.Context, in *EventSource, opts ...grpc.CallOption) (Eventing_StartEventSourceClient, error)
}

type eventingClient struct {
	cc *grpc.ClientConn
}

func NewEventingClient(cc *grpc.ClientConn) EventingClient {
	return &eventingClient{cc}
}

func (c *eventingClient) StartEventSource(ctx context.Context, in *EventSource, opts ...grpc.CallOption) (Eventing_StartEventSourceClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Eventing_serviceDesc.Streams[0], "/generic.Eventing/StartEventSource", opts...)
	if err != nil {
		return nil, err
	}
	x := &eventingStartEventSourceClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Eventing_StartEventSourceClient interface {
	Recv() (*Event, error)
	grpc.ClientStream
}

type eventingStartEventSourceClient struct {
	grpc.ClientStream
}

func (x *eventingStartEventSourceClient) Recv() (*Event, error) {
	m := new(Event)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// EventingServer is the server API for Eventing service.
type EventingServer interface {
	StartEventSource(*EventSource, Eventing_StartEventSourceServer) error
}

// UnimplementedEventingServer can be embedded to have forward compatible implementations.
type UnimplementedEventingServer struct {
}

func (*UnimplementedEventingServer) StartEventSource(req *EventSource, srv Eventing_StartEventSourceServer) error {
	return status.Errorf(codes.Unimplemented, "method StartEventSource not implemented")
}

func RegisterEventingServer(s *grpc.Server, srv EventingServer) {
	s.RegisterService(&_Eventing_serviceDesc, srv)
}

func _Eventing_StartEventSource_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(EventSource)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(EventingServer).StartEventSource(m, &eventingStartEventSourceServer{stream})
}

type Eventing_StartEventSourceServer interface {
	Send(*Event) error
	grpc.ServerStream
}

type eventingStartEventSourceServer struct {
	grpc.ServerStream
}

func (x *eventingStartEventSourceServer) Send(m *Event) error {
	return x.ServerStream.SendMsg(m)
}

var _Eventing_serviceDesc = grpc.ServiceDesc{
	ServiceName: "generic.Eventing",
	HandlerType: (*EventingServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StartEventSource",
			Handler:       _Eventing_StartEventSource_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "server/application/events.proto",
}

func (m *EventSource) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventSource) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventSource) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Config != nil {
		i -= len(m.Config)
		copy(dAtA[i:], m.Config)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Config)))
		i--
		dAtA[i] = 0x12
	}
	if m.Name == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("name")
	} else {
		i -= len(*m.Name)
		copy(dAtA[i:], *m.Name)
		i = encodeVarintEvents(dAtA, i, uint64(len(*m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Event) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Event) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Event) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Payload == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("payload")
	} else {
		i -= len(m.Payload)
		copy(dAtA[i:], m.Payload)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Payload)))
		i--
		dAtA[i] = 0x12
	}
	if m.Name == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("name")
	} else {
		i -= len(*m.Name)
		copy(dAtA[i:], *m.Name)
		i = encodeVarintEvents(dAtA, i, uint64(len(*m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventPayload) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventPayload) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventPayload) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.AppVersions != nil {
		{
			size, err := m.AppVersions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Errors) > 0 {
		for iNdEx := len(m.Errors) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Errors[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEvents(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Source == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("source")
	} else {
		{
			size, err := m.Source.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Object == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("object")
	} else {
		i -= len(m.Object)
		copy(dAtA[i:], m.Object)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Object)))
		i--
		dAtA[i] = 0x12
	}
	i -= len(m.Timestamp)
	copy(dAtA[i:], m.Timestamp)
	i = encodeVarintEvents(dAtA, i, uint64(len(m.Timestamp)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ObjectSource) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ObjectSource) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ObjectSource) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	i -= len(m.TrackingMethod)
	copy(dAtA[i:], m.TrackingMethod)
	i = encodeVarintEvents(dAtA, i, uint64(len(m.TrackingMethod)))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xba
	i -= len(m.AppInstanceLabelKey)
	copy(dAtA[i:], m.AppInstanceLabelKey)
	i = encodeVarintEvents(dAtA, i, uint64(len(m.AppInstanceLabelKey)))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xb2
	i -= len(m.AppNamespace)
	copy(dAtA[i:], m.AppNamespace)
	i = encodeVarintEvents(dAtA, i, uint64(len(m.AppNamespace)))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xaa
	i -= len(m.AppUID)
	copy(dAtA[i:], m.AppUID)
	i = encodeVarintEvents(dAtA, i, uint64(len(m.AppUID)))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xa2
	i -= len(m.OperationSyncRevision)
	copy(dAtA[i:], m.OperationSyncRevision)
	i = encodeVarintEvents(dAtA, i, uint64(len(m.OperationSyncRevision)))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x9a
	i = encodeVarintEvents(dAtA, i, uint64(m.HistoryId))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x90
	i -= len(m.Cluster)
	copy(dAtA[i:], m.Cluster)
	i = encodeVarintEvents(dAtA, i, uint64(len(m.Cluster)))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x8a
	if m.HealthMessage != nil {
		i -= len(*m.HealthMessage)
		copy(dAtA[i:], *m.HealthMessage)
		i = encodeVarintEvents(dAtA, i, uint64(len(*m.HealthMessage)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if m.HealthStatus != nil {
		i -= len(*m.HealthStatus)
		copy(dAtA[i:], *m.HealthStatus)
		i = encodeVarintEvents(dAtA, i, uint64(len(*m.HealthStatus)))
		i--
		dAtA[i] = 0x7a
	}
	if m.SyncFinishedAt != nil {
		{
			size, err := m.SyncFinishedAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	{
		size, err := m.SyncStartedAt.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x6a
	i -= len(m.SyncStatus)
	copy(dAtA[i:], m.SyncStatus)
	i = encodeVarintEvents(dAtA, i, uint64(len(m.SyncStatus)))
	i--
	dAtA[i] = 0x62
	if len(m.AppLabels) > 0 {
		for k := range m.AppLabels {
			v := m.AppLabels[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintEvents(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintEvents(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintEvents(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x5a
		}
	}
	i -= len(m.AppName)
	copy(dAtA[i:], m.AppName)
	i = encodeVarintEvents(dAtA, i, uint64(len(m.AppName)))
	i--
	dAtA[i] = 0x52
	if m.CommitDate != nil {
		{
			size, err := m.CommitDate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	i -= len(m.CommitAuthor)
	copy(dAtA[i:], m.CommitAuthor)
	i = encodeVarintEvents(dAtA, i, uint64(len(m.CommitAuthor)))
	i--
	dAtA[i] = 0x42
	i -= len(m.CommitMessage)
	copy(dAtA[i:], m.CommitMessage)
	i = encodeVarintEvents(dAtA, i, uint64(len(m.CommitMessage)))
	i--
	dAtA[i] = 0x3a
	i -= len(m.Revision)
	copy(dAtA[i:], m.Revision)
	i = encodeVarintEvents(dAtA, i, uint64(len(m.Revision)))
	i--
	dAtA[i] = 0x32
	i -= len(m.Path)
	copy(dAtA[i:], m.Path)
	i = encodeVarintEvents(dAtA, i, uint64(len(m.Path)))
	i--
	dAtA[i] = 0x2a
	i -= len(m.RepoURL)
	copy(dAtA[i:], m.RepoURL)
	i = encodeVarintEvents(dAtA, i, uint64(len(m.RepoURL)))
	i--
	dAtA[i] = 0x22
	i -= len(m.GitManifest)
	copy(dAtA[i:], m.GitManifest)
	i = encodeVarintEvents(dAtA, i, uint64(len(m.GitManifest)))
	i--
	dAtA[i] = 0x1a
	i -= len(m.ActualManifest)
	copy(dAtA[i:], m.ActualManifest)
	i = encodeVarintEvents(dAtA, i, uint64(len(m.ActualManifest)))
	i--
	dAtA[i] = 0x12
	i -= len(m.DesiredManifest)
	copy(dAtA[i:], m.DesiredManifest)
	i = encodeVarintEvents(dAtA, i, uint64(len(m.DesiredManifest)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ObjectError) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ObjectError) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ObjectError) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.LastSeen.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	i -= len(m.Message)
	copy(dAtA[i:], m.Message)
	i = encodeVarintEvents(dAtA, i, uint64(len(m.Message)))
	i--
	dAtA[i] = 0x1a
	i -= len(m.Level)
	copy(dAtA[i:], m.Level)
	i = encodeVarintEvents(dAtA, i, uint64(len(m.Level)))
	i--
	dAtA[i] = 0x12
	i -= len(m.Type)
	copy(dAtA[i:], m.Type)
	i = encodeVarintEvents(dAtA, i, uint64(len(m.Type)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *Dependencies) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Dependencies) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Dependencies) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Requirements != nil {
		i -= len(*m.Requirements)
		copy(dAtA[i:], *m.Requirements)
		i = encodeVarintEvents(dAtA, i, uint64(len(*m.Requirements)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Deps != nil {
		i -= len(*m.Deps)
		copy(dAtA[i:], *m.Deps)
		i = encodeVarintEvents(dAtA, i, uint64(len(*m.Deps)))
		i--
		dAtA[i] = 0x12
	}
	if m.Lock != nil {
		i -= len(*m.Lock)
		copy(dAtA[i:], *m.Lock)
		i = encodeVarintEvents(dAtA, i, uint64(len(*m.Lock)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ApplicationVersions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ApplicationVersions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ApplicationVersions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Dependencies != nil {
		{
			size, err := m.Dependencies.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.AppVersion != nil {
		i -= len(*m.AppVersion)
		copy(dAtA[i:], *m.AppVersion)
		i = encodeVarintEvents(dAtA, i, uint64(len(*m.AppVersion)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintEvents(dAtA []byte, offset int, v uint64) int {
	offset -= sovEvents(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *EventSource) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Name != nil {
		l = len(*m.Name)
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.Config != nil {
		l = len(m.Config)
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Event) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Name != nil {
		l = len(*m.Name)
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.Payload != nil {
		l = len(m.Payload)
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EventPayload) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Timestamp)
	n += 1 + l + sovEvents(uint64(l))
	if m.Object != nil {
		l = len(m.Object)
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.Source != nil {
		l = m.Source.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	if len(m.Errors) > 0 {
		for _, e := range m.Errors {
			l = e.Size()
			n += 1 + l + sovEvents(uint64(l))
		}
	}
	if m.AppVersions != nil {
		l = m.AppVersions.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ObjectSource) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DesiredManifest)
	n += 1 + l + sovEvents(uint64(l))
	l = len(m.ActualManifest)
	n += 1 + l + sovEvents(uint64(l))
	l = len(m.GitManifest)
	n += 1 + l + sovEvents(uint64(l))
	l = len(m.RepoURL)
	n += 1 + l + sovEvents(uint64(l))
	l = len(m.Path)
	n += 1 + l + sovEvents(uint64(l))
	l = len(m.Revision)
	n += 1 + l + sovEvents(uint64(l))
	l = len(m.CommitMessage)
	n += 1 + l + sovEvents(uint64(l))
	l = len(m.CommitAuthor)
	n += 1 + l + sovEvents(uint64(l))
	if m.CommitDate != nil {
		l = m.CommitDate.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.AppName)
	n += 1 + l + sovEvents(uint64(l))
	if len(m.AppLabels) > 0 {
		for k, v := range m.AppLabels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovEvents(uint64(len(k))) + 1 + len(v) + sovEvents(uint64(len(v)))
			n += mapEntrySize + 1 + sovEvents(uint64(mapEntrySize))
		}
	}
	l = len(m.SyncStatus)
	n += 1 + l + sovEvents(uint64(l))
	l = m.SyncStartedAt.Size()
	n += 1 + l + sovEvents(uint64(l))
	if m.SyncFinishedAt != nil {
		l = m.SyncFinishedAt.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.HealthStatus != nil {
		l = len(*m.HealthStatus)
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.HealthMessage != nil {
		l = len(*m.HealthMessage)
		n += 2 + l + sovEvents(uint64(l))
	}
	l = len(m.Cluster)
	n += 2 + l + sovEvents(uint64(l))
	n += 2 + sovEvents(uint64(m.HistoryId))
	l = len(m.OperationSyncRevision)
	n += 2 + l + sovEvents(uint64(l))
	l = len(m.AppUID)
	n += 2 + l + sovEvents(uint64(l))
	l = len(m.AppNamespace)
	n += 2 + l + sovEvents(uint64(l))
	l = len(m.AppInstanceLabelKey)
	n += 2 + l + sovEvents(uint64(l))
	l = len(m.TrackingMethod)
	n += 2 + l + sovEvents(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ObjectError) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Type)
	n += 1 + l + sovEvents(uint64(l))
	l = len(m.Level)
	n += 1 + l + sovEvents(uint64(l))
	l = len(m.Message)
	n += 1 + l + sovEvents(uint64(l))
	l = m.LastSeen.Size()
	n += 1 + l + sovEvents(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Dependencies) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Lock != nil {
		l = len(*m.Lock)
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.Deps != nil {
		l = len(*m.Deps)
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.Requirements != nil {
		l = len(*m.Requirements)
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ApplicationVersions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AppVersion != nil {
		l = len(*m.AppVersion)
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.Dependencies != nil {
		l = m.Dependencies.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovEvents(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozEvents(x uint64) (n int) {
	return sovEvents(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *EventSource) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventSource: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventSource: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Name = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Config = append(m.Config[:0], dAtA[iNdEx:postIndex]...)
			if m.Config == nil {
				m.Config = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("name")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Event) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Event: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Event: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Name = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload[:0], dAtA[iNdEx:postIndex]...)
			if m.Payload == nil {
				m.Payload = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("name")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("payload")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventPayload) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventPayload: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventPayload: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Timestamp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Object", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Object = append(m.Object[:0], dAtA[iNdEx:postIndex]...)
			if m.Object == nil {
				m.Object = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Source == nil {
				m.Source = &ObjectSource{}
			}
			if err := m.Source.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Errors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Errors = append(m.Errors, &ObjectError{})
			if err := m.Errors[len(m.Errors)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppVersions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AppVersions == nil {
				m.AppVersions = &ApplicationVersions{}
			}
			if err := m.AppVersions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("timestamp")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("object")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("source")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ObjectSource) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ObjectSource: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ObjectSource: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DesiredManifest", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DesiredManifest = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActualManifest", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ActualManifest = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GitManifest", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GitManifest = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepoURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RepoURL = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Revision", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Revision = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CommitMessage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitAuthor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CommitAuthor = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitDate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CommitDate == nil {
				m.CommitDate = &v1.Time{}
			}
			if err := m.CommitDate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppLabels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AppLabels == nil {
				m.AppLabels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowEvents
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowEvents
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthEvents
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthEvents
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowEvents
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthEvents
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthEvents
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipEvents(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthEvents
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.AppLabels[mapkey] = mapvalue
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SyncStatus", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SyncStatus = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SyncStartedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SyncStartedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SyncFinishedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SyncFinishedAt == nil {
				m.SyncFinishedAt = &v1.Time{}
			}
			if err := m.SyncFinishedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HealthStatus", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.HealthStatus = &s
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HealthMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.HealthMessage = &s
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cluster", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cluster = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HistoryId", wireType)
			}
			m.HistoryId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HistoryId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperationSyncRevision", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OperationSyncRevision = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppUID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppUID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppNamespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppNamespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppInstanceLabelKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppInstanceLabelKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrackingMethod", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TrackingMethod = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ObjectError) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ObjectError: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ObjectError: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Level = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastSeen", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LastSeen.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Dependencies) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Dependencies: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Dependencies: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lock", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Lock = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deps", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Deps = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Requirements", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Requirements = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ApplicationVersions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ApplicationVersions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ApplicationVersions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.AppVersion = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dependencies", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Dependencies == nil {
				m.Dependencies = &Dependencies{}
			}
			if err := m.Dependencies.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipEvents(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthEvents
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupEvents
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthEvents
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthEvents        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowEvents          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupEvents = fmt.Errorf("proto: unexpected end of group")
)
