// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package mocks

import (
	"github.com/argoproj/gitops-engine/pkg/cache"
	"github.com/argoproj/gitops-engine/pkg/utils/kube"
	mock "github.com/stretchr/testify/mock"
	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"k8s.io/apimachinery/pkg/util/managedfields"
	"k8s.io/kubectl/pkg/util/openapi"
)

// NewClusterCache creates a new instance of ClusterCache. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewClusterCache(t interface {
	mock.TestingT
	Cleanup(func())
}) *ClusterCache {
	mock := &ClusterCache{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// ClusterCache is an autogenerated mock type for the ClusterCache type
type ClusterCache struct {
	mock.Mock
}

type ClusterCache_Expecter struct {
	mock *mock.Mock
}

func (_m *ClusterCache) EXPECT() *ClusterCache_Expecter {
	return &ClusterCache_Expecter{mock: &_m.Mock}
}

// EnsureSynced provides a mock function for the type ClusterCache
func (_mock *ClusterCache) EnsureSynced() error {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for EnsureSynced")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func() error); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// ClusterCache_EnsureSynced_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EnsureSynced'
type ClusterCache_EnsureSynced_Call struct {
	*mock.Call
}

// EnsureSynced is a helper method to define mock.On call
func (_e *ClusterCache_Expecter) EnsureSynced() *ClusterCache_EnsureSynced_Call {
	return &ClusterCache_EnsureSynced_Call{Call: _e.mock.On("EnsureSynced")}
}

func (_c *ClusterCache_EnsureSynced_Call) Run(run func()) *ClusterCache_EnsureSynced_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *ClusterCache_EnsureSynced_Call) Return(err error) *ClusterCache_EnsureSynced_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *ClusterCache_EnsureSynced_Call) RunAndReturn(run func() error) *ClusterCache_EnsureSynced_Call {
	_c.Call.Return(run)
	return _c
}

// FindResources provides a mock function for the type ClusterCache
func (_mock *ClusterCache) FindResources(namespace string, predicates ...func(r *cache.Resource) bool) map[kube.ResourceKey]*cache.Resource {
	// func(r *cache.Resource) bool
	_va := make([]interface{}, len(predicates))
	for _i := range predicates {
		_va[_i] = predicates[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, namespace)
	_ca = append(_ca, _va...)
	ret := _mock.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for FindResources")
	}

	var r0 map[kube.ResourceKey]*cache.Resource
	if returnFunc, ok := ret.Get(0).(func(string, ...func(r *cache.Resource) bool) map[kube.ResourceKey]*cache.Resource); ok {
		r0 = returnFunc(namespace, predicates...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[kube.ResourceKey]*cache.Resource)
		}
	}
	return r0
}

// ClusterCache_FindResources_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FindResources'
type ClusterCache_FindResources_Call struct {
	*mock.Call
}

// FindResources is a helper method to define mock.On call
//   - namespace string
//   - predicates ...func(r *cache.Resource) bool
func (_e *ClusterCache_Expecter) FindResources(namespace interface{}, predicates ...interface{}) *ClusterCache_FindResources_Call {
	return &ClusterCache_FindResources_Call{Call: _e.mock.On("FindResources",
		append([]interface{}{namespace}, predicates...)...)}
}

func (_c *ClusterCache_FindResources_Call) Run(run func(namespace string, predicates ...func(r *cache.Resource) bool)) *ClusterCache_FindResources_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		var arg1 []func(r *cache.Resource) bool
		variadicArgs := make([]func(r *cache.Resource) bool, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(func(r *cache.Resource) bool)
			}
		}
		arg1 = variadicArgs
		run(
			arg0,
			arg1...,
		)
	})
	return _c
}

func (_c *ClusterCache_FindResources_Call) Return(resourceKeyToResource map[kube.ResourceKey]*cache.Resource) *ClusterCache_FindResources_Call {
	_c.Call.Return(resourceKeyToResource)
	return _c
}

func (_c *ClusterCache_FindResources_Call) RunAndReturn(run func(namespace string, predicates ...func(r *cache.Resource) bool) map[kube.ResourceKey]*cache.Resource) *ClusterCache_FindResources_Call {
	_c.Call.Return(run)
	return _c
}

// GetAPIResources provides a mock function for the type ClusterCache
func (_mock *ClusterCache) GetAPIResources() []kube.APIResourceInfo {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetAPIResources")
	}

	var r0 []kube.APIResourceInfo
	if returnFunc, ok := ret.Get(0).(func() []kube.APIResourceInfo); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]kube.APIResourceInfo)
		}
	}
	return r0
}

// ClusterCache_GetAPIResources_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAPIResources'
type ClusterCache_GetAPIResources_Call struct {
	*mock.Call
}

// GetAPIResources is a helper method to define mock.On call
func (_e *ClusterCache_Expecter) GetAPIResources() *ClusterCache_GetAPIResources_Call {
	return &ClusterCache_GetAPIResources_Call{Call: _e.mock.On("GetAPIResources")}
}

func (_c *ClusterCache_GetAPIResources_Call) Run(run func()) *ClusterCache_GetAPIResources_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *ClusterCache_GetAPIResources_Call) Return(aPIResourceInfos []kube.APIResourceInfo) *ClusterCache_GetAPIResources_Call {
	_c.Call.Return(aPIResourceInfos)
	return _c
}

func (_c *ClusterCache_GetAPIResources_Call) RunAndReturn(run func() []kube.APIResourceInfo) *ClusterCache_GetAPIResources_Call {
	_c.Call.Return(run)
	return _c
}

// GetClusterInfo provides a mock function for the type ClusterCache
func (_mock *ClusterCache) GetClusterInfo() cache.ClusterInfo {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetClusterInfo")
	}

	var r0 cache.ClusterInfo
	if returnFunc, ok := ret.Get(0).(func() cache.ClusterInfo); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(cache.ClusterInfo)
	}
	return r0
}

// ClusterCache_GetClusterInfo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetClusterInfo'
type ClusterCache_GetClusterInfo_Call struct {
	*mock.Call
}

// GetClusterInfo is a helper method to define mock.On call
func (_e *ClusterCache_Expecter) GetClusterInfo() *ClusterCache_GetClusterInfo_Call {
	return &ClusterCache_GetClusterInfo_Call{Call: _e.mock.On("GetClusterInfo")}
}

func (_c *ClusterCache_GetClusterInfo_Call) Run(run func()) *ClusterCache_GetClusterInfo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *ClusterCache_GetClusterInfo_Call) Return(clusterInfo cache.ClusterInfo) *ClusterCache_GetClusterInfo_Call {
	_c.Call.Return(clusterInfo)
	return _c
}

func (_c *ClusterCache_GetClusterInfo_Call) RunAndReturn(run func() cache.ClusterInfo) *ClusterCache_GetClusterInfo_Call {
	_c.Call.Return(run)
	return _c
}

// GetGVKParser provides a mock function for the type ClusterCache
func (_mock *ClusterCache) GetGVKParser() *managedfields.GvkParser {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetGVKParser")
	}

	var r0 *managedfields.GvkParser
	if returnFunc, ok := ret.Get(0).(func() *managedfields.GvkParser); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*managedfields.GvkParser)
		}
	}
	return r0
}

// ClusterCache_GetGVKParser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetGVKParser'
type ClusterCache_GetGVKParser_Call struct {
	*mock.Call
}

// GetGVKParser is a helper method to define mock.On call
func (_e *ClusterCache_Expecter) GetGVKParser() *ClusterCache_GetGVKParser_Call {
	return &ClusterCache_GetGVKParser_Call{Call: _e.mock.On("GetGVKParser")}
}

func (_c *ClusterCache_GetGVKParser_Call) Run(run func()) *ClusterCache_GetGVKParser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *ClusterCache_GetGVKParser_Call) Return(gvkParser *managedfields.GvkParser) *ClusterCache_GetGVKParser_Call {
	_c.Call.Return(gvkParser)
	return _c
}

func (_c *ClusterCache_GetGVKParser_Call) RunAndReturn(run func() *managedfields.GvkParser) *ClusterCache_GetGVKParser_Call {
	_c.Call.Return(run)
	return _c
}

// GetManagedLiveObjs provides a mock function for the type ClusterCache
func (_mock *ClusterCache) GetManagedLiveObjs(targetObjs []*unstructured.Unstructured, isManaged func(r *cache.Resource) bool) (map[kube.ResourceKey]*unstructured.Unstructured, error) {
	ret := _mock.Called(targetObjs, isManaged)

	if len(ret) == 0 {
		panic("no return value specified for GetManagedLiveObjs")
	}

	var r0 map[kube.ResourceKey]*unstructured.Unstructured
	var r1 error
	if returnFunc, ok := ret.Get(0).(func([]*unstructured.Unstructured, func(r *cache.Resource) bool) (map[kube.ResourceKey]*unstructured.Unstructured, error)); ok {
		return returnFunc(targetObjs, isManaged)
	}
	if returnFunc, ok := ret.Get(0).(func([]*unstructured.Unstructured, func(r *cache.Resource) bool) map[kube.ResourceKey]*unstructured.Unstructured); ok {
		r0 = returnFunc(targetObjs, isManaged)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[kube.ResourceKey]*unstructured.Unstructured)
		}
	}
	if returnFunc, ok := ret.Get(1).(func([]*unstructured.Unstructured, func(r *cache.Resource) bool) error); ok {
		r1 = returnFunc(targetObjs, isManaged)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ClusterCache_GetManagedLiveObjs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetManagedLiveObjs'
type ClusterCache_GetManagedLiveObjs_Call struct {
	*mock.Call
}

// GetManagedLiveObjs is a helper method to define mock.On call
//   - targetObjs []*unstructured.Unstructured
//   - isManaged func(r *cache.Resource) bool
func (_e *ClusterCache_Expecter) GetManagedLiveObjs(targetObjs interface{}, isManaged interface{}) *ClusterCache_GetManagedLiveObjs_Call {
	return &ClusterCache_GetManagedLiveObjs_Call{Call: _e.mock.On("GetManagedLiveObjs", targetObjs, isManaged)}
}

func (_c *ClusterCache_GetManagedLiveObjs_Call) Run(run func(targetObjs []*unstructured.Unstructured, isManaged func(r *cache.Resource) bool)) *ClusterCache_GetManagedLiveObjs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 []*unstructured.Unstructured
		if args[0] != nil {
			arg0 = args[0].([]*unstructured.Unstructured)
		}
		var arg1 func(r *cache.Resource) bool
		if args[1] != nil {
			arg1 = args[1].(func(r *cache.Resource) bool)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *ClusterCache_GetManagedLiveObjs_Call) Return(resourceKeyToUnstructured map[kube.ResourceKey]*unstructured.Unstructured, err error) *ClusterCache_GetManagedLiveObjs_Call {
	_c.Call.Return(resourceKeyToUnstructured, err)
	return _c
}

func (_c *ClusterCache_GetManagedLiveObjs_Call) RunAndReturn(run func(targetObjs []*unstructured.Unstructured, isManaged func(r *cache.Resource) bool) (map[kube.ResourceKey]*unstructured.Unstructured, error)) *ClusterCache_GetManagedLiveObjs_Call {
	_c.Call.Return(run)
	return _c
}

// GetOpenAPISchema provides a mock function for the type ClusterCache
func (_mock *ClusterCache) GetOpenAPISchema() openapi.Resources {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetOpenAPISchema")
	}

	var r0 openapi.Resources
	if returnFunc, ok := ret.Get(0).(func() openapi.Resources); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(openapi.Resources)
		}
	}
	return r0
}

// ClusterCache_GetOpenAPISchema_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetOpenAPISchema'
type ClusterCache_GetOpenAPISchema_Call struct {
	*mock.Call
}

// GetOpenAPISchema is a helper method to define mock.On call
func (_e *ClusterCache_Expecter) GetOpenAPISchema() *ClusterCache_GetOpenAPISchema_Call {
	return &ClusterCache_GetOpenAPISchema_Call{Call: _e.mock.On("GetOpenAPISchema")}
}

func (_c *ClusterCache_GetOpenAPISchema_Call) Run(run func()) *ClusterCache_GetOpenAPISchema_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *ClusterCache_GetOpenAPISchema_Call) Return(resources openapi.Resources) *ClusterCache_GetOpenAPISchema_Call {
	_c.Call.Return(resources)
	return _c
}

func (_c *ClusterCache_GetOpenAPISchema_Call) RunAndReturn(run func() openapi.Resources) *ClusterCache_GetOpenAPISchema_Call {
	_c.Call.Return(run)
	return _c
}

// GetServerVersion provides a mock function for the type ClusterCache
func (_mock *ClusterCache) GetServerVersion() string {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetServerVersion")
	}

	var r0 string
	if returnFunc, ok := ret.Get(0).(func() string); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(string)
	}
	return r0
}

// ClusterCache_GetServerVersion_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetServerVersion'
type ClusterCache_GetServerVersion_Call struct {
	*mock.Call
}

// GetServerVersion is a helper method to define mock.On call
func (_e *ClusterCache_Expecter) GetServerVersion() *ClusterCache_GetServerVersion_Call {
	return &ClusterCache_GetServerVersion_Call{Call: _e.mock.On("GetServerVersion")}
}

func (_c *ClusterCache_GetServerVersion_Call) Run(run func()) *ClusterCache_GetServerVersion_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *ClusterCache_GetServerVersion_Call) Return(s string) *ClusterCache_GetServerVersion_Call {
	_c.Call.Return(s)
	return _c
}

func (_c *ClusterCache_GetServerVersion_Call) RunAndReturn(run func() string) *ClusterCache_GetServerVersion_Call {
	_c.Call.Return(run)
	return _c
}

// Invalidate provides a mock function for the type ClusterCache
func (_mock *ClusterCache) Invalidate(opts ...cache.UpdateSettingsFunc) {
	// cache.UpdateSettingsFunc
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	_mock.Called(_ca...)
	return
}

// ClusterCache_Invalidate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Invalidate'
type ClusterCache_Invalidate_Call struct {
	*mock.Call
}

// Invalidate is a helper method to define mock.On call
//   - opts ...cache.UpdateSettingsFunc
func (_e *ClusterCache_Expecter) Invalidate(opts ...interface{}) *ClusterCache_Invalidate_Call {
	return &ClusterCache_Invalidate_Call{Call: _e.mock.On("Invalidate",
		append([]interface{}{}, opts...)...)}
}

func (_c *ClusterCache_Invalidate_Call) Run(run func(opts ...cache.UpdateSettingsFunc)) *ClusterCache_Invalidate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 []cache.UpdateSettingsFunc
		variadicArgs := make([]cache.UpdateSettingsFunc, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(cache.UpdateSettingsFunc)
			}
		}
		arg0 = variadicArgs
		run(
			arg0...,
		)
	})
	return _c
}

func (_c *ClusterCache_Invalidate_Call) Return() *ClusterCache_Invalidate_Call {
	_c.Call.Return()
	return _c
}

func (_c *ClusterCache_Invalidate_Call) RunAndReturn(run func(opts ...cache.UpdateSettingsFunc)) *ClusterCache_Invalidate_Call {
	_c.Run(run)
	return _c
}

// IsNamespaced provides a mock function for the type ClusterCache
func (_mock *ClusterCache) IsNamespaced(gk schema.GroupKind) (bool, error) {
	ret := _mock.Called(gk)

	if len(ret) == 0 {
		panic("no return value specified for IsNamespaced")
	}

	var r0 bool
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(schema.GroupKind) (bool, error)); ok {
		return returnFunc(gk)
	}
	if returnFunc, ok := ret.Get(0).(func(schema.GroupKind) bool); ok {
		r0 = returnFunc(gk)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func(schema.GroupKind) error); ok {
		r1 = returnFunc(gk)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ClusterCache_IsNamespaced_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IsNamespaced'
type ClusterCache_IsNamespaced_Call struct {
	*mock.Call
}

// IsNamespaced is a helper method to define mock.On call
//   - gk schema.GroupKind
func (_e *ClusterCache_Expecter) IsNamespaced(gk interface{}) *ClusterCache_IsNamespaced_Call {
	return &ClusterCache_IsNamespaced_Call{Call: _e.mock.On("IsNamespaced", gk)}
}

func (_c *ClusterCache_IsNamespaced_Call) Run(run func(gk schema.GroupKind)) *ClusterCache_IsNamespaced_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 schema.GroupKind
		if args[0] != nil {
			arg0 = args[0].(schema.GroupKind)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *ClusterCache_IsNamespaced_Call) Return(b bool, err error) *ClusterCache_IsNamespaced_Call {
	_c.Call.Return(b, err)
	return _c
}

func (_c *ClusterCache_IsNamespaced_Call) RunAndReturn(run func(gk schema.GroupKind) (bool, error)) *ClusterCache_IsNamespaced_Call {
	_c.Call.Return(run)
	return _c
}

// IterateHierarchyV2 provides a mock function for the type ClusterCache
func (_mock *ClusterCache) IterateHierarchyV2(keys []kube.ResourceKey, action func(resource *cache.Resource, namespaceResources map[kube.ResourceKey]*cache.Resource) bool) {
	_mock.Called(keys, action)
	return
}

// ClusterCache_IterateHierarchyV2_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IterateHierarchyV2'
type ClusterCache_IterateHierarchyV2_Call struct {
	*mock.Call
}

// IterateHierarchyV2 is a helper method to define mock.On call
//   - keys []kube.ResourceKey
//   - action func(resource *cache.Resource, namespaceResources map[kube.ResourceKey]*cache.Resource) bool
func (_e *ClusterCache_Expecter) IterateHierarchyV2(keys interface{}, action interface{}) *ClusterCache_IterateHierarchyV2_Call {
	return &ClusterCache_IterateHierarchyV2_Call{Call: _e.mock.On("IterateHierarchyV2", keys, action)}
}

func (_c *ClusterCache_IterateHierarchyV2_Call) Run(run func(keys []kube.ResourceKey, action func(resource *cache.Resource, namespaceResources map[kube.ResourceKey]*cache.Resource) bool)) *ClusterCache_IterateHierarchyV2_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 []kube.ResourceKey
		if args[0] != nil {
			arg0 = args[0].([]kube.ResourceKey)
		}
		var arg1 func(resource *cache.Resource, namespaceResources map[kube.ResourceKey]*cache.Resource) bool
		if args[1] != nil {
			arg1 = args[1].(func(resource *cache.Resource, namespaceResources map[kube.ResourceKey]*cache.Resource) bool)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *ClusterCache_IterateHierarchyV2_Call) Return() *ClusterCache_IterateHierarchyV2_Call {
	_c.Call.Return()
	return _c
}

func (_c *ClusterCache_IterateHierarchyV2_Call) RunAndReturn(run func(keys []kube.ResourceKey, action func(resource *cache.Resource, namespaceResources map[kube.ResourceKey]*cache.Resource) bool)) *ClusterCache_IterateHierarchyV2_Call {
	_c.Run(run)
	return _c
}

// OnEvent provides a mock function for the type ClusterCache
func (_mock *ClusterCache) OnEvent(handler cache.OnEventHandler) cache.Unsubscribe {
	ret := _mock.Called(handler)

	if len(ret) == 0 {
		panic("no return value specified for OnEvent")
	}

	var r0 cache.Unsubscribe
	if returnFunc, ok := ret.Get(0).(func(cache.OnEventHandler) cache.Unsubscribe); ok {
		r0 = returnFunc(handler)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(cache.Unsubscribe)
		}
	}
	return r0
}

// ClusterCache_OnEvent_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OnEvent'
type ClusterCache_OnEvent_Call struct {
	*mock.Call
}

// OnEvent is a helper method to define mock.On call
//   - handler cache.OnEventHandler
func (_e *ClusterCache_Expecter) OnEvent(handler interface{}) *ClusterCache_OnEvent_Call {
	return &ClusterCache_OnEvent_Call{Call: _e.mock.On("OnEvent", handler)}
}

func (_c *ClusterCache_OnEvent_Call) Run(run func(handler cache.OnEventHandler)) *ClusterCache_OnEvent_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 cache.OnEventHandler
		if args[0] != nil {
			arg0 = args[0].(cache.OnEventHandler)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *ClusterCache_OnEvent_Call) Return(unsubscribe cache.Unsubscribe) *ClusterCache_OnEvent_Call {
	_c.Call.Return(unsubscribe)
	return _c
}

func (_c *ClusterCache_OnEvent_Call) RunAndReturn(run func(handler cache.OnEventHandler) cache.Unsubscribe) *ClusterCache_OnEvent_Call {
	_c.Call.Return(run)
	return _c
}

// OnProcessEventsHandler provides a mock function for the type ClusterCache
func (_mock *ClusterCache) OnProcessEventsHandler(handler cache.OnProcessEventsHandler) cache.Unsubscribe {
	ret := _mock.Called(handler)

	if len(ret) == 0 {
		panic("no return value specified for OnProcessEventsHandler")
	}

	var r0 cache.Unsubscribe
	if returnFunc, ok := ret.Get(0).(func(cache.OnProcessEventsHandler) cache.Unsubscribe); ok {
		r0 = returnFunc(handler)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(cache.Unsubscribe)
		}
	}
	return r0
}

// ClusterCache_OnProcessEventsHandler_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OnProcessEventsHandler'
type ClusterCache_OnProcessEventsHandler_Call struct {
	*mock.Call
}

// OnProcessEventsHandler is a helper method to define mock.On call
//   - handler cache.OnProcessEventsHandler
func (_e *ClusterCache_Expecter) OnProcessEventsHandler(handler interface{}) *ClusterCache_OnProcessEventsHandler_Call {
	return &ClusterCache_OnProcessEventsHandler_Call{Call: _e.mock.On("OnProcessEventsHandler", handler)}
}

func (_c *ClusterCache_OnProcessEventsHandler_Call) Run(run func(handler cache.OnProcessEventsHandler)) *ClusterCache_OnProcessEventsHandler_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 cache.OnProcessEventsHandler
		if args[0] != nil {
			arg0 = args[0].(cache.OnProcessEventsHandler)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *ClusterCache_OnProcessEventsHandler_Call) Return(unsubscribe cache.Unsubscribe) *ClusterCache_OnProcessEventsHandler_Call {
	_c.Call.Return(unsubscribe)
	return _c
}

func (_c *ClusterCache_OnProcessEventsHandler_Call) RunAndReturn(run func(handler cache.OnProcessEventsHandler) cache.Unsubscribe) *ClusterCache_OnProcessEventsHandler_Call {
	_c.Call.Return(run)
	return _c
}

// OnResourceUpdated provides a mock function for the type ClusterCache
func (_mock *ClusterCache) OnResourceUpdated(handler cache.OnResourceUpdatedHandler) cache.Unsubscribe {
	ret := _mock.Called(handler)

	if len(ret) == 0 {
		panic("no return value specified for OnResourceUpdated")
	}

	var r0 cache.Unsubscribe
	if returnFunc, ok := ret.Get(0).(func(cache.OnResourceUpdatedHandler) cache.Unsubscribe); ok {
		r0 = returnFunc(handler)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(cache.Unsubscribe)
		}
	}
	return r0
}

// ClusterCache_OnResourceUpdated_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OnResourceUpdated'
type ClusterCache_OnResourceUpdated_Call struct {
	*mock.Call
}

// OnResourceUpdated is a helper method to define mock.On call
//   - handler cache.OnResourceUpdatedHandler
func (_e *ClusterCache_Expecter) OnResourceUpdated(handler interface{}) *ClusterCache_OnResourceUpdated_Call {
	return &ClusterCache_OnResourceUpdated_Call{Call: _e.mock.On("OnResourceUpdated", handler)}
}

func (_c *ClusterCache_OnResourceUpdated_Call) Run(run func(handler cache.OnResourceUpdatedHandler)) *ClusterCache_OnResourceUpdated_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 cache.OnResourceUpdatedHandler
		if args[0] != nil {
			arg0 = args[0].(cache.OnResourceUpdatedHandler)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *ClusterCache_OnResourceUpdated_Call) Return(unsubscribe cache.Unsubscribe) *ClusterCache_OnResourceUpdated_Call {
	_c.Call.Return(unsubscribe)
	return _c
}

func (_c *ClusterCache_OnResourceUpdated_Call) RunAndReturn(run func(handler cache.OnResourceUpdatedHandler) cache.Unsubscribe) *ClusterCache_OnResourceUpdated_Call {
	_c.Call.Return(run)
	return _c
}
