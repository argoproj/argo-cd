// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package mocks

import (
	"context"

	cache0 "github.com/argoproj/argo-cd/v3/controller/cache"
	"github.com/argoproj/argo-cd/v3/pkg/apis/application/v1alpha1"
	"github.com/argoproj/gitops-engine/pkg/cache"
	"github.com/argoproj/gitops-engine/pkg/utils/kube"
	mock "github.com/stretchr/testify/mock"
	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
	"k8s.io/apimachinery/pkg/runtime/schema"
)

// NewLiveStateCache creates a new instance of LiveStateCache. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewLiveStateCache(t interface {
	mock.TestingT
	Cleanup(func())
}) *LiveStateCache {
	mock := &LiveStateCache{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// LiveStateCache is an autogenerated mock type for the LiveStateCache type
type LiveStateCache struct {
	mock.Mock
}

type LiveStateCache_Expecter struct {
	mock *mock.Mock
}

func (_m *LiveStateCache) EXPECT() *LiveStateCache_Expecter {
	return &LiveStateCache_Expecter{mock: &_m.Mock}
}

// GetClusterCache provides a mock function for the type LiveStateCache
func (_mock *LiveStateCache) GetClusterCache(server *v1alpha1.Cluster) (cache.ClusterCache, error) {
	ret := _mock.Called(server)

	if len(ret) == 0 {
		panic("no return value specified for GetClusterCache")
	}

	var r0 cache.ClusterCache
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*v1alpha1.Cluster) (cache.ClusterCache, error)); ok {
		return returnFunc(server)
	}
	if returnFunc, ok := ret.Get(0).(func(*v1alpha1.Cluster) cache.ClusterCache); ok {
		r0 = returnFunc(server)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(cache.ClusterCache)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*v1alpha1.Cluster) error); ok {
		r1 = returnFunc(server)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// LiveStateCache_GetClusterCache_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetClusterCache'
type LiveStateCache_GetClusterCache_Call struct {
	*mock.Call
}

// GetClusterCache is a helper method to define mock.On call
//   - server *v1alpha1.Cluster
func (_e *LiveStateCache_Expecter) GetClusterCache(server interface{}) *LiveStateCache_GetClusterCache_Call {
	return &LiveStateCache_GetClusterCache_Call{Call: _e.mock.On("GetClusterCache", server)}
}

func (_c *LiveStateCache_GetClusterCache_Call) Run(run func(server *v1alpha1.Cluster)) *LiveStateCache_GetClusterCache_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *v1alpha1.Cluster
		if args[0] != nil {
			arg0 = args[0].(*v1alpha1.Cluster)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *LiveStateCache_GetClusterCache_Call) Return(clusterCache cache.ClusterCache, err error) *LiveStateCache_GetClusterCache_Call {
	_c.Call.Return(clusterCache, err)
	return _c
}

func (_c *LiveStateCache_GetClusterCache_Call) RunAndReturn(run func(server *v1alpha1.Cluster) (cache.ClusterCache, error)) *LiveStateCache_GetClusterCache_Call {
	_c.Call.Return(run)
	return _c
}

// GetClustersInfo provides a mock function for the type LiveStateCache
func (_mock *LiveStateCache) GetClustersInfo() []cache.ClusterInfo {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetClustersInfo")
	}

	var r0 []cache.ClusterInfo
	if returnFunc, ok := ret.Get(0).(func() []cache.ClusterInfo); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]cache.ClusterInfo)
		}
	}
	return r0
}

// LiveStateCache_GetClustersInfo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetClustersInfo'
type LiveStateCache_GetClustersInfo_Call struct {
	*mock.Call
}

// GetClustersInfo is a helper method to define mock.On call
func (_e *LiveStateCache_Expecter) GetClustersInfo() *LiveStateCache_GetClustersInfo_Call {
	return &LiveStateCache_GetClustersInfo_Call{Call: _e.mock.On("GetClustersInfo")}
}

func (_c *LiveStateCache_GetClustersInfo_Call) Run(run func()) *LiveStateCache_GetClustersInfo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *LiveStateCache_GetClustersInfo_Call) Return(clusterInfos []cache.ClusterInfo) *LiveStateCache_GetClustersInfo_Call {
	_c.Call.Return(clusterInfos)
	return _c
}

func (_c *LiveStateCache_GetClustersInfo_Call) RunAndReturn(run func() []cache.ClusterInfo) *LiveStateCache_GetClustersInfo_Call {
	_c.Call.Return(run)
	return _c
}

// GetManagedLiveObjs provides a mock function for the type LiveStateCache
func (_mock *LiveStateCache) GetManagedLiveObjs(destCluster *v1alpha1.Cluster, a *v1alpha1.Application, targetObjs []*unstructured.Unstructured) (map[kube.ResourceKey]*unstructured.Unstructured, error) {
	ret := _mock.Called(destCluster, a, targetObjs)

	if len(ret) == 0 {
		panic("no return value specified for GetManagedLiveObjs")
	}

	var r0 map[kube.ResourceKey]*unstructured.Unstructured
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*v1alpha1.Cluster, *v1alpha1.Application, []*unstructured.Unstructured) (map[kube.ResourceKey]*unstructured.Unstructured, error)); ok {
		return returnFunc(destCluster, a, targetObjs)
	}
	if returnFunc, ok := ret.Get(0).(func(*v1alpha1.Cluster, *v1alpha1.Application, []*unstructured.Unstructured) map[kube.ResourceKey]*unstructured.Unstructured); ok {
		r0 = returnFunc(destCluster, a, targetObjs)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[kube.ResourceKey]*unstructured.Unstructured)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*v1alpha1.Cluster, *v1alpha1.Application, []*unstructured.Unstructured) error); ok {
		r1 = returnFunc(destCluster, a, targetObjs)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// LiveStateCache_GetManagedLiveObjs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetManagedLiveObjs'
type LiveStateCache_GetManagedLiveObjs_Call struct {
	*mock.Call
}

// GetManagedLiveObjs is a helper method to define mock.On call
//   - destCluster *v1alpha1.Cluster
//   - a *v1alpha1.Application
//   - targetObjs []*unstructured.Unstructured
func (_e *LiveStateCache_Expecter) GetManagedLiveObjs(destCluster interface{}, a interface{}, targetObjs interface{}) *LiveStateCache_GetManagedLiveObjs_Call {
	return &LiveStateCache_GetManagedLiveObjs_Call{Call: _e.mock.On("GetManagedLiveObjs", destCluster, a, targetObjs)}
}

func (_c *LiveStateCache_GetManagedLiveObjs_Call) Run(run func(destCluster *v1alpha1.Cluster, a *v1alpha1.Application, targetObjs []*unstructured.Unstructured)) *LiveStateCache_GetManagedLiveObjs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *v1alpha1.Cluster
		if args[0] != nil {
			arg0 = args[0].(*v1alpha1.Cluster)
		}
		var arg1 *v1alpha1.Application
		if args[1] != nil {
			arg1 = args[1].(*v1alpha1.Application)
		}
		var arg2 []*unstructured.Unstructured
		if args[2] != nil {
			arg2 = args[2].([]*unstructured.Unstructured)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *LiveStateCache_GetManagedLiveObjs_Call) Return(resourceKeyToUnstructured map[kube.ResourceKey]*unstructured.Unstructured, err error) *LiveStateCache_GetManagedLiveObjs_Call {
	_c.Call.Return(resourceKeyToUnstructured, err)
	return _c
}

func (_c *LiveStateCache_GetManagedLiveObjs_Call) RunAndReturn(run func(destCluster *v1alpha1.Cluster, a *v1alpha1.Application, targetObjs []*unstructured.Unstructured) (map[kube.ResourceKey]*unstructured.Unstructured, error)) *LiveStateCache_GetManagedLiveObjs_Call {
	_c.Call.Return(run)
	return _c
}

// GetNamespaceTopLevelResources provides a mock function for the type LiveStateCache
func (_mock *LiveStateCache) GetNamespaceTopLevelResources(server *v1alpha1.Cluster, namespace string) (map[kube.ResourceKey]v1alpha1.ResourceNode, error) {
	ret := _mock.Called(server, namespace)

	if len(ret) == 0 {
		panic("no return value specified for GetNamespaceTopLevelResources")
	}

	var r0 map[kube.ResourceKey]v1alpha1.ResourceNode
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*v1alpha1.Cluster, string) (map[kube.ResourceKey]v1alpha1.ResourceNode, error)); ok {
		return returnFunc(server, namespace)
	}
	if returnFunc, ok := ret.Get(0).(func(*v1alpha1.Cluster, string) map[kube.ResourceKey]v1alpha1.ResourceNode); ok {
		r0 = returnFunc(server, namespace)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[kube.ResourceKey]v1alpha1.ResourceNode)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*v1alpha1.Cluster, string) error); ok {
		r1 = returnFunc(server, namespace)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// LiveStateCache_GetNamespaceTopLevelResources_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetNamespaceTopLevelResources'
type LiveStateCache_GetNamespaceTopLevelResources_Call struct {
	*mock.Call
}

// GetNamespaceTopLevelResources is a helper method to define mock.On call
//   - server *v1alpha1.Cluster
//   - namespace string
func (_e *LiveStateCache_Expecter) GetNamespaceTopLevelResources(server interface{}, namespace interface{}) *LiveStateCache_GetNamespaceTopLevelResources_Call {
	return &LiveStateCache_GetNamespaceTopLevelResources_Call{Call: _e.mock.On("GetNamespaceTopLevelResources", server, namespace)}
}

func (_c *LiveStateCache_GetNamespaceTopLevelResources_Call) Run(run func(server *v1alpha1.Cluster, namespace string)) *LiveStateCache_GetNamespaceTopLevelResources_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *v1alpha1.Cluster
		if args[0] != nil {
			arg0 = args[0].(*v1alpha1.Cluster)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *LiveStateCache_GetNamespaceTopLevelResources_Call) Return(resourceKeyToResourceNode map[kube.ResourceKey]v1alpha1.ResourceNode, err error) *LiveStateCache_GetNamespaceTopLevelResources_Call {
	_c.Call.Return(resourceKeyToResourceNode, err)
	return _c
}

func (_c *LiveStateCache_GetNamespaceTopLevelResources_Call) RunAndReturn(run func(server *v1alpha1.Cluster, namespace string) (map[kube.ResourceKey]v1alpha1.ResourceNode, error)) *LiveStateCache_GetNamespaceTopLevelResources_Call {
	_c.Call.Return(run)
	return _c
}

// GetVersionsInfo provides a mock function for the type LiveStateCache
func (_mock *LiveStateCache) GetVersionsInfo(server *v1alpha1.Cluster) (string, []kube.APIResourceInfo, error) {
	ret := _mock.Called(server)

	if len(ret) == 0 {
		panic("no return value specified for GetVersionsInfo")
	}

	var r0 string
	var r1 []kube.APIResourceInfo
	var r2 error
	if returnFunc, ok := ret.Get(0).(func(*v1alpha1.Cluster) (string, []kube.APIResourceInfo, error)); ok {
		return returnFunc(server)
	}
	if returnFunc, ok := ret.Get(0).(func(*v1alpha1.Cluster) string); ok {
		r0 = returnFunc(server)
	} else {
		r0 = ret.Get(0).(string)
	}
	if returnFunc, ok := ret.Get(1).(func(*v1alpha1.Cluster) []kube.APIResourceInfo); ok {
		r1 = returnFunc(server)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).([]kube.APIResourceInfo)
		}
	}
	if returnFunc, ok := ret.Get(2).(func(*v1alpha1.Cluster) error); ok {
		r2 = returnFunc(server)
	} else {
		r2 = ret.Error(2)
	}
	return r0, r1, r2
}

// LiveStateCache_GetVersionsInfo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetVersionsInfo'
type LiveStateCache_GetVersionsInfo_Call struct {
	*mock.Call
}

// GetVersionsInfo is a helper method to define mock.On call
//   - server *v1alpha1.Cluster
func (_e *LiveStateCache_Expecter) GetVersionsInfo(server interface{}) *LiveStateCache_GetVersionsInfo_Call {
	return &LiveStateCache_GetVersionsInfo_Call{Call: _e.mock.On("GetVersionsInfo", server)}
}

func (_c *LiveStateCache_GetVersionsInfo_Call) Run(run func(server *v1alpha1.Cluster)) *LiveStateCache_GetVersionsInfo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *v1alpha1.Cluster
		if args[0] != nil {
			arg0 = args[0].(*v1alpha1.Cluster)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *LiveStateCache_GetVersionsInfo_Call) Return(s string, aPIResourceInfos []kube.APIResourceInfo, err error) *LiveStateCache_GetVersionsInfo_Call {
	_c.Call.Return(s, aPIResourceInfos, err)
	return _c
}

func (_c *LiveStateCache_GetVersionsInfo_Call) RunAndReturn(run func(server *v1alpha1.Cluster) (string, []kube.APIResourceInfo, error)) *LiveStateCache_GetVersionsInfo_Call {
	_c.Call.Return(run)
	return _c
}

// Init provides a mock function for the type LiveStateCache
func (_mock *LiveStateCache) Init() error {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Init")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func() error); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// LiveStateCache_Init_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Init'
type LiveStateCache_Init_Call struct {
	*mock.Call
}

// Init is a helper method to define mock.On call
func (_e *LiveStateCache_Expecter) Init() *LiveStateCache_Init_Call {
	return &LiveStateCache_Init_Call{Call: _e.mock.On("Init")}
}

func (_c *LiveStateCache_Init_Call) Run(run func()) *LiveStateCache_Init_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *LiveStateCache_Init_Call) Return(err error) *LiveStateCache_Init_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *LiveStateCache_Init_Call) RunAndReturn(run func() error) *LiveStateCache_Init_Call {
	_c.Call.Return(run)
	return _c
}

// IsNamespaced provides a mock function for the type LiveStateCache
func (_mock *LiveStateCache) IsNamespaced(server *v1alpha1.Cluster, gk schema.GroupKind) (bool, error) {
	ret := _mock.Called(server, gk)

	if len(ret) == 0 {
		panic("no return value specified for IsNamespaced")
	}

	var r0 bool
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*v1alpha1.Cluster, schema.GroupKind) (bool, error)); ok {
		return returnFunc(server, gk)
	}
	if returnFunc, ok := ret.Get(0).(func(*v1alpha1.Cluster, schema.GroupKind) bool); ok {
		r0 = returnFunc(server, gk)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func(*v1alpha1.Cluster, schema.GroupKind) error); ok {
		r1 = returnFunc(server, gk)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// LiveStateCache_IsNamespaced_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IsNamespaced'
type LiveStateCache_IsNamespaced_Call struct {
	*mock.Call
}

// IsNamespaced is a helper method to define mock.On call
//   - server *v1alpha1.Cluster
//   - gk schema.GroupKind
func (_e *LiveStateCache_Expecter) IsNamespaced(server interface{}, gk interface{}) *LiveStateCache_IsNamespaced_Call {
	return &LiveStateCache_IsNamespaced_Call{Call: _e.mock.On("IsNamespaced", server, gk)}
}

func (_c *LiveStateCache_IsNamespaced_Call) Run(run func(server *v1alpha1.Cluster, gk schema.GroupKind)) *LiveStateCache_IsNamespaced_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *v1alpha1.Cluster
		if args[0] != nil {
			arg0 = args[0].(*v1alpha1.Cluster)
		}
		var arg1 schema.GroupKind
		if args[1] != nil {
			arg1 = args[1].(schema.GroupKind)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *LiveStateCache_IsNamespaced_Call) Return(b bool, err error) *LiveStateCache_IsNamespaced_Call {
	_c.Call.Return(b, err)
	return _c
}

func (_c *LiveStateCache_IsNamespaced_Call) RunAndReturn(run func(server *v1alpha1.Cluster, gk schema.GroupKind) (bool, error)) *LiveStateCache_IsNamespaced_Call {
	_c.Call.Return(run)
	return _c
}

// IterateHierarchy provides a mock function for the type LiveStateCache
func (_mock *LiveStateCache) IterateHierarchy(server *v1alpha1.Cluster, key kube.ResourceKey, action func(child v1alpha1.ResourceNode, appName string) bool) error {
	ret := _mock.Called(server, key, action)

	if len(ret) == 0 {
		panic("no return value specified for IterateHierarchy")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(*v1alpha1.Cluster, kube.ResourceKey, func(child v1alpha1.ResourceNode, appName string) bool) error); ok {
		r0 = returnFunc(server, key, action)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// LiveStateCache_IterateHierarchy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IterateHierarchy'
type LiveStateCache_IterateHierarchy_Call struct {
	*mock.Call
}

// IterateHierarchy is a helper method to define mock.On call
//   - server *v1alpha1.Cluster
//   - key kube.ResourceKey
//   - action func(child v1alpha1.ResourceNode, appName string) bool
func (_e *LiveStateCache_Expecter) IterateHierarchy(server interface{}, key interface{}, action interface{}) *LiveStateCache_IterateHierarchy_Call {
	return &LiveStateCache_IterateHierarchy_Call{Call: _e.mock.On("IterateHierarchy", server, key, action)}
}

func (_c *LiveStateCache_IterateHierarchy_Call) Run(run func(server *v1alpha1.Cluster, key kube.ResourceKey, action func(child v1alpha1.ResourceNode, appName string) bool)) *LiveStateCache_IterateHierarchy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *v1alpha1.Cluster
		if args[0] != nil {
			arg0 = args[0].(*v1alpha1.Cluster)
		}
		var arg1 kube.ResourceKey
		if args[1] != nil {
			arg1 = args[1].(kube.ResourceKey)
		}
		var arg2 func(child v1alpha1.ResourceNode, appName string) bool
		if args[2] != nil {
			arg2 = args[2].(func(child v1alpha1.ResourceNode, appName string) bool)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *LiveStateCache_IterateHierarchy_Call) Return(err error) *LiveStateCache_IterateHierarchy_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *LiveStateCache_IterateHierarchy_Call) RunAndReturn(run func(server *v1alpha1.Cluster, key kube.ResourceKey, action func(child v1alpha1.ResourceNode, appName string) bool) error) *LiveStateCache_IterateHierarchy_Call {
	_c.Call.Return(run)
	return _c
}

// IterateHierarchyV2 provides a mock function for the type LiveStateCache
func (_mock *LiveStateCache) IterateHierarchyV2(server *v1alpha1.Cluster, keys []kube.ResourceKey, action func(child v1alpha1.ResourceNode, appName string) bool) error {
	ret := _mock.Called(server, keys, action)

	if len(ret) == 0 {
		panic("no return value specified for IterateHierarchyV2")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(*v1alpha1.Cluster, []kube.ResourceKey, func(child v1alpha1.ResourceNode, appName string) bool) error); ok {
		r0 = returnFunc(server, keys, action)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// LiveStateCache_IterateHierarchyV2_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IterateHierarchyV2'
type LiveStateCache_IterateHierarchyV2_Call struct {
	*mock.Call
}

// IterateHierarchyV2 is a helper method to define mock.On call
//   - server *v1alpha1.Cluster
//   - keys []kube.ResourceKey
//   - action func(child v1alpha1.ResourceNode, appName string) bool
func (_e *LiveStateCache_Expecter) IterateHierarchyV2(server interface{}, keys interface{}, action interface{}) *LiveStateCache_IterateHierarchyV2_Call {
	return &LiveStateCache_IterateHierarchyV2_Call{Call: _e.mock.On("IterateHierarchyV2", server, keys, action)}
}

func (_c *LiveStateCache_IterateHierarchyV2_Call) Run(run func(server *v1alpha1.Cluster, keys []kube.ResourceKey, action func(child v1alpha1.ResourceNode, appName string) bool)) *LiveStateCache_IterateHierarchyV2_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *v1alpha1.Cluster
		if args[0] != nil {
			arg0 = args[0].(*v1alpha1.Cluster)
		}
		var arg1 []kube.ResourceKey
		if args[1] != nil {
			arg1 = args[1].([]kube.ResourceKey)
		}
		var arg2 func(child v1alpha1.ResourceNode, appName string) bool
		if args[2] != nil {
			arg2 = args[2].(func(child v1alpha1.ResourceNode, appName string) bool)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *LiveStateCache_IterateHierarchyV2_Call) Return(err error) *LiveStateCache_IterateHierarchyV2_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *LiveStateCache_IterateHierarchyV2_Call) RunAndReturn(run func(server *v1alpha1.Cluster, keys []kube.ResourceKey, action func(child v1alpha1.ResourceNode, appName string) bool) error) *LiveStateCache_IterateHierarchyV2_Call {
	_c.Call.Return(run)
	return _c
}

// IterateResources provides a mock function for the type LiveStateCache
func (_mock *LiveStateCache) IterateResources(server *v1alpha1.Cluster, callback func(res *cache.Resource, info *cache0.ResourceInfo)) error {
	ret := _mock.Called(server, callback)

	if len(ret) == 0 {
		panic("no return value specified for IterateResources")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(*v1alpha1.Cluster, func(res *cache.Resource, info *cache0.ResourceInfo)) error); ok {
		r0 = returnFunc(server, callback)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// LiveStateCache_IterateResources_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IterateResources'
type LiveStateCache_IterateResources_Call struct {
	*mock.Call
}

// IterateResources is a helper method to define mock.On call
//   - server *v1alpha1.Cluster
//   - callback func(res *cache.Resource, info *cache0.ResourceInfo)
func (_e *LiveStateCache_Expecter) IterateResources(server interface{}, callback interface{}) *LiveStateCache_IterateResources_Call {
	return &LiveStateCache_IterateResources_Call{Call: _e.mock.On("IterateResources", server, callback)}
}

func (_c *LiveStateCache_IterateResources_Call) Run(run func(server *v1alpha1.Cluster, callback func(res *cache.Resource, info *cache0.ResourceInfo))) *LiveStateCache_IterateResources_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *v1alpha1.Cluster
		if args[0] != nil {
			arg0 = args[0].(*v1alpha1.Cluster)
		}
		var arg1 func(res *cache.Resource, info *cache0.ResourceInfo)
		if args[1] != nil {
			arg1 = args[1].(func(res *cache.Resource, info *cache0.ResourceInfo))
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *LiveStateCache_IterateResources_Call) Return(err error) *LiveStateCache_IterateResources_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *LiveStateCache_IterateResources_Call) RunAndReturn(run func(server *v1alpha1.Cluster, callback func(res *cache.Resource, info *cache0.ResourceInfo)) error) *LiveStateCache_IterateResources_Call {
	_c.Call.Return(run)
	return _c
}

// Run provides a mock function for the type LiveStateCache
func (_mock *LiveStateCache) Run(ctx context.Context) error {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Run")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) error); ok {
		r0 = returnFunc(ctx)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// LiveStateCache_Run_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Run'
type LiveStateCache_Run_Call struct {
	*mock.Call
}

// Run is a helper method to define mock.On call
//   - ctx context.Context
func (_e *LiveStateCache_Expecter) Run(ctx interface{}) *LiveStateCache_Run_Call {
	return &LiveStateCache_Run_Call{Call: _e.mock.On("Run", ctx)}
}

func (_c *LiveStateCache_Run_Call) Run(run func(ctx context.Context)) *LiveStateCache_Run_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *LiveStateCache_Run_Call) Return(err error) *LiveStateCache_Run_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *LiveStateCache_Run_Call) RunAndReturn(run func(ctx context.Context) error) *LiveStateCache_Run_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateShard provides a mock function for the type LiveStateCache
func (_mock *LiveStateCache) UpdateShard(shard int) bool {
	ret := _mock.Called(shard)

	if len(ret) == 0 {
		panic("no return value specified for UpdateShard")
	}

	var r0 bool
	if returnFunc, ok := ret.Get(0).(func(int) bool); ok {
		r0 = returnFunc(shard)
	} else {
		r0 = ret.Get(0).(bool)
	}
	return r0
}

// LiveStateCache_UpdateShard_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateShard'
type LiveStateCache_UpdateShard_Call struct {
	*mock.Call
}

// UpdateShard is a helper method to define mock.On call
//   - shard int
func (_e *LiveStateCache_Expecter) UpdateShard(shard interface{}) *LiveStateCache_UpdateShard_Call {
	return &LiveStateCache_UpdateShard_Call{Call: _e.mock.On("UpdateShard", shard)}
}

func (_c *LiveStateCache_UpdateShard_Call) Run(run func(shard int)) *LiveStateCache_UpdateShard_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 int
		if args[0] != nil {
			arg0 = args[0].(int)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *LiveStateCache_UpdateShard_Call) Return(b bool) *LiveStateCache_UpdateShard_Call {
	_c.Call.Return(b)
	return _c
}

func (_c *LiveStateCache_UpdateShard_Call) RunAndReturn(run func(shard int) bool) *LiveStateCache_UpdateShard_Call {
	_c.Call.Return(run)
	return _c
}
