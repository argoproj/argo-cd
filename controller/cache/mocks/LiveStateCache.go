// Code generated by mockery. DO NOT EDIT.

package mocks

import (
	context "context"

	cache "github.com/argoproj/gitops-engine/pkg/cache"

	controllercache "github.com/argoproj/argo-cd/v3/controller/cache"

	kube "github.com/argoproj/gitops-engine/pkg/utils/kube"

	mock "github.com/stretchr/testify/mock"

	schema "k8s.io/apimachinery/pkg/runtime/schema"

	unstructured "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"

	v1alpha1 "github.com/argoproj/argo-cd/v3/pkg/apis/application/v1alpha1"
)

// LiveStateCache is an autogenerated mock type for the LiveStateCache type
type LiveStateCache struct {
	mock.Mock
}

type LiveStateCache_Expecter struct {
	mock *mock.Mock
}

func (_m *LiveStateCache) EXPECT() *LiveStateCache_Expecter {
	return &LiveStateCache_Expecter{mock: &_m.Mock}
}

// GetClusterCache provides a mock function with given fields: server
func (_m *LiveStateCache) GetClusterCache(server *v1alpha1.Cluster) (cache.ClusterCache, error) {
	ret := _m.Called(server)

	if len(ret) == 0 {
		panic("no return value specified for GetClusterCache")
	}

	var r0 cache.ClusterCache
	var r1 error
	if rf, ok := ret.Get(0).(func(*v1alpha1.Cluster) (cache.ClusterCache, error)); ok {
		return rf(server)
	}
	if rf, ok := ret.Get(0).(func(*v1alpha1.Cluster) cache.ClusterCache); ok {
		r0 = rf(server)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(cache.ClusterCache)
		}
	}

	if rf, ok := ret.Get(1).(func(*v1alpha1.Cluster) error); ok {
		r1 = rf(server)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LiveStateCache_GetClusterCache_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetClusterCache'
type LiveStateCache_GetClusterCache_Call struct {
	*mock.Call
}

// GetClusterCache is a helper method to define mock.On call
//   - server *v1alpha1.Cluster
func (_e *LiveStateCache_Expecter) GetClusterCache(server interface{}) *LiveStateCache_GetClusterCache_Call {
	return &LiveStateCache_GetClusterCache_Call{Call: _e.mock.On("GetClusterCache", server)}
}

func (_c *LiveStateCache_GetClusterCache_Call) Run(run func(server *v1alpha1.Cluster)) *LiveStateCache_GetClusterCache_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*v1alpha1.Cluster))
	})
	return _c
}

func (_c *LiveStateCache_GetClusterCache_Call) Return(_a0 cache.ClusterCache, _a1 error) *LiveStateCache_GetClusterCache_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *LiveStateCache_GetClusterCache_Call) RunAndReturn(run func(*v1alpha1.Cluster) (cache.ClusterCache, error)) *LiveStateCache_GetClusterCache_Call {
	_c.Call.Return(run)
	return _c
}

// GetClustersInfo provides a mock function with no fields
func (_m *LiveStateCache) GetClustersInfo() []cache.ClusterInfo {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetClustersInfo")
	}

	var r0 []cache.ClusterInfo
	if rf, ok := ret.Get(0).(func() []cache.ClusterInfo); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]cache.ClusterInfo)
		}
	}

	return r0
}

// LiveStateCache_GetClustersInfo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetClustersInfo'
type LiveStateCache_GetClustersInfo_Call struct {
	*mock.Call
}

// GetClustersInfo is a helper method to define mock.On call
func (_e *LiveStateCache_Expecter) GetClustersInfo() *LiveStateCache_GetClustersInfo_Call {
	return &LiveStateCache_GetClustersInfo_Call{Call: _e.mock.On("GetClustersInfo")}
}

func (_c *LiveStateCache_GetClustersInfo_Call) Run(run func()) *LiveStateCache_GetClustersInfo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *LiveStateCache_GetClustersInfo_Call) Return(_a0 []cache.ClusterInfo) *LiveStateCache_GetClustersInfo_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *LiveStateCache_GetClustersInfo_Call) RunAndReturn(run func() []cache.ClusterInfo) *LiveStateCache_GetClustersInfo_Call {
	_c.Call.Return(run)
	return _c
}

// GetManagedLiveObjs provides a mock function with given fields: destCluster, a, targetObjs
func (_m *LiveStateCache) GetManagedLiveObjs(destCluster *v1alpha1.Cluster, a *v1alpha1.Application, targetObjs []*unstructured.Unstructured) (map[kube.ResourceKey]*unstructured.Unstructured, error) {
	ret := _m.Called(destCluster, a, targetObjs)

	if len(ret) == 0 {
		panic("no return value specified for GetManagedLiveObjs")
	}

	var r0 map[kube.ResourceKey]*unstructured.Unstructured
	var r1 error
	if rf, ok := ret.Get(0).(func(*v1alpha1.Cluster, *v1alpha1.Application, []*unstructured.Unstructured) (map[kube.ResourceKey]*unstructured.Unstructured, error)); ok {
		return rf(destCluster, a, targetObjs)
	}
	if rf, ok := ret.Get(0).(func(*v1alpha1.Cluster, *v1alpha1.Application, []*unstructured.Unstructured) map[kube.ResourceKey]*unstructured.Unstructured); ok {
		r0 = rf(destCluster, a, targetObjs)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[kube.ResourceKey]*unstructured.Unstructured)
		}
	}

	if rf, ok := ret.Get(1).(func(*v1alpha1.Cluster, *v1alpha1.Application, []*unstructured.Unstructured) error); ok {
		r1 = rf(destCluster, a, targetObjs)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LiveStateCache_GetManagedLiveObjs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetManagedLiveObjs'
type LiveStateCache_GetManagedLiveObjs_Call struct {
	*mock.Call
}

// GetManagedLiveObjs is a helper method to define mock.On call
//   - destCluster *v1alpha1.Cluster
//   - a *v1alpha1.Application
//   - targetObjs []*unstructured.Unstructured
func (_e *LiveStateCache_Expecter) GetManagedLiveObjs(destCluster interface{}, a interface{}, targetObjs interface{}) *LiveStateCache_GetManagedLiveObjs_Call {
	return &LiveStateCache_GetManagedLiveObjs_Call{Call: _e.mock.On("GetManagedLiveObjs", destCluster, a, targetObjs)}
}

func (_c *LiveStateCache_GetManagedLiveObjs_Call) Run(run func(destCluster *v1alpha1.Cluster, a *v1alpha1.Application, targetObjs []*unstructured.Unstructured)) *LiveStateCache_GetManagedLiveObjs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*v1alpha1.Cluster), args[1].(*v1alpha1.Application), args[2].([]*unstructured.Unstructured))
	})
	return _c
}

func (_c *LiveStateCache_GetManagedLiveObjs_Call) Return(_a0 map[kube.ResourceKey]*unstructured.Unstructured, _a1 error) *LiveStateCache_GetManagedLiveObjs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *LiveStateCache_GetManagedLiveObjs_Call) RunAndReturn(run func(*v1alpha1.Cluster, *v1alpha1.Application, []*unstructured.Unstructured) (map[kube.ResourceKey]*unstructured.Unstructured, error)) *LiveStateCache_GetManagedLiveObjs_Call {
	_c.Call.Return(run)
	return _c
}

// GetNamespaceTopLevelResources provides a mock function with given fields: server, namespace
func (_m *LiveStateCache) GetNamespaceTopLevelResources(server *v1alpha1.Cluster, namespace string) (map[kube.ResourceKey]v1alpha1.ResourceNode, error) {
	ret := _m.Called(server, namespace)

	if len(ret) == 0 {
		panic("no return value specified for GetNamespaceTopLevelResources")
	}

	var r0 map[kube.ResourceKey]v1alpha1.ResourceNode
	var r1 error
	if rf, ok := ret.Get(0).(func(*v1alpha1.Cluster, string) (map[kube.ResourceKey]v1alpha1.ResourceNode, error)); ok {
		return rf(server, namespace)
	}
	if rf, ok := ret.Get(0).(func(*v1alpha1.Cluster, string) map[kube.ResourceKey]v1alpha1.ResourceNode); ok {
		r0 = rf(server, namespace)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[kube.ResourceKey]v1alpha1.ResourceNode)
		}
	}

	if rf, ok := ret.Get(1).(func(*v1alpha1.Cluster, string) error); ok {
		r1 = rf(server, namespace)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LiveStateCache_GetNamespaceTopLevelResources_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetNamespaceTopLevelResources'
type LiveStateCache_GetNamespaceTopLevelResources_Call struct {
	*mock.Call
}

// GetNamespaceTopLevelResources is a helper method to define mock.On call
//   - server *v1alpha1.Cluster
//   - namespace string
func (_e *LiveStateCache_Expecter) GetNamespaceTopLevelResources(server interface{}, namespace interface{}) *LiveStateCache_GetNamespaceTopLevelResources_Call {
	return &LiveStateCache_GetNamespaceTopLevelResources_Call{Call: _e.mock.On("GetNamespaceTopLevelResources", server, namespace)}
}

func (_c *LiveStateCache_GetNamespaceTopLevelResources_Call) Run(run func(server *v1alpha1.Cluster, namespace string)) *LiveStateCache_GetNamespaceTopLevelResources_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*v1alpha1.Cluster), args[1].(string))
	})
	return _c
}

func (_c *LiveStateCache_GetNamespaceTopLevelResources_Call) Return(_a0 map[kube.ResourceKey]v1alpha1.ResourceNode, _a1 error) *LiveStateCache_GetNamespaceTopLevelResources_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *LiveStateCache_GetNamespaceTopLevelResources_Call) RunAndReturn(run func(*v1alpha1.Cluster, string) (map[kube.ResourceKey]v1alpha1.ResourceNode, error)) *LiveStateCache_GetNamespaceTopLevelResources_Call {
	_c.Call.Return(run)
	return _c
}

// GetVersionsInfo provides a mock function with given fields: server
func (_m *LiveStateCache) GetVersionsInfo(server *v1alpha1.Cluster) (string, []kube.APIResourceInfo, error) {
	ret := _m.Called(server)

	if len(ret) == 0 {
		panic("no return value specified for GetVersionsInfo")
	}

	var r0 string
	var r1 []kube.APIResourceInfo
	var r2 error
	if rf, ok := ret.Get(0).(func(*v1alpha1.Cluster) (string, []kube.APIResourceInfo, error)); ok {
		return rf(server)
	}
	if rf, ok := ret.Get(0).(func(*v1alpha1.Cluster) string); ok {
		r0 = rf(server)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(*v1alpha1.Cluster) []kube.APIResourceInfo); ok {
		r1 = rf(server)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).([]kube.APIResourceInfo)
		}
	}

	if rf, ok := ret.Get(2).(func(*v1alpha1.Cluster) error); ok {
		r2 = rf(server)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// LiveStateCache_GetVersionsInfo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetVersionsInfo'
type LiveStateCache_GetVersionsInfo_Call struct {
	*mock.Call
}

// GetVersionsInfo is a helper method to define mock.On call
//   - server *v1alpha1.Cluster
func (_e *LiveStateCache_Expecter) GetVersionsInfo(server interface{}) *LiveStateCache_GetVersionsInfo_Call {
	return &LiveStateCache_GetVersionsInfo_Call{Call: _e.mock.On("GetVersionsInfo", server)}
}

func (_c *LiveStateCache_GetVersionsInfo_Call) Run(run func(server *v1alpha1.Cluster)) *LiveStateCache_GetVersionsInfo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*v1alpha1.Cluster))
	})
	return _c
}

func (_c *LiveStateCache_GetVersionsInfo_Call) Return(_a0 string, _a1 []kube.APIResourceInfo, _a2 error) *LiveStateCache_GetVersionsInfo_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *LiveStateCache_GetVersionsInfo_Call) RunAndReturn(run func(*v1alpha1.Cluster) (string, []kube.APIResourceInfo, error)) *LiveStateCache_GetVersionsInfo_Call {
	_c.Call.Return(run)
	return _c
}

// Init provides a mock function with no fields
func (_m *LiveStateCache) Init() error {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Init")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// LiveStateCache_Init_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Init'
type LiveStateCache_Init_Call struct {
	*mock.Call
}

// Init is a helper method to define mock.On call
func (_e *LiveStateCache_Expecter) Init() *LiveStateCache_Init_Call {
	return &LiveStateCache_Init_Call{Call: _e.mock.On("Init")}
}

func (_c *LiveStateCache_Init_Call) Run(run func()) *LiveStateCache_Init_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *LiveStateCache_Init_Call) Return(_a0 error) *LiveStateCache_Init_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *LiveStateCache_Init_Call) RunAndReturn(run func() error) *LiveStateCache_Init_Call {
	_c.Call.Return(run)
	return _c
}

// IsNamespaced provides a mock function with given fields: server, gk
func (_m *LiveStateCache) IsNamespaced(server *v1alpha1.Cluster, gk schema.GroupKind) (bool, error) {
	ret := _m.Called(server, gk)

	if len(ret) == 0 {
		panic("no return value specified for IsNamespaced")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(*v1alpha1.Cluster, schema.GroupKind) (bool, error)); ok {
		return rf(server, gk)
	}
	if rf, ok := ret.Get(0).(func(*v1alpha1.Cluster, schema.GroupKind) bool); ok {
		r0 = rf(server, gk)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(*v1alpha1.Cluster, schema.GroupKind) error); ok {
		r1 = rf(server, gk)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LiveStateCache_IsNamespaced_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IsNamespaced'
type LiveStateCache_IsNamespaced_Call struct {
	*mock.Call
}

// IsNamespaced is a helper method to define mock.On call
//   - server *v1alpha1.Cluster
//   - gk schema.GroupKind
func (_e *LiveStateCache_Expecter) IsNamespaced(server interface{}, gk interface{}) *LiveStateCache_IsNamespaced_Call {
	return &LiveStateCache_IsNamespaced_Call{Call: _e.mock.On("IsNamespaced", server, gk)}
}

func (_c *LiveStateCache_IsNamespaced_Call) Run(run func(server *v1alpha1.Cluster, gk schema.GroupKind)) *LiveStateCache_IsNamespaced_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*v1alpha1.Cluster), args[1].(schema.GroupKind))
	})
	return _c
}

func (_c *LiveStateCache_IsNamespaced_Call) Return(_a0 bool, _a1 error) *LiveStateCache_IsNamespaced_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *LiveStateCache_IsNamespaced_Call) RunAndReturn(run func(*v1alpha1.Cluster, schema.GroupKind) (bool, error)) *LiveStateCache_IsNamespaced_Call {
	_c.Call.Return(run)
	return _c
}

// IterateHierarchy provides a mock function with given fields: server, key, action
func (_m *LiveStateCache) IterateHierarchy(server *v1alpha1.Cluster, key kube.ResourceKey, action func(v1alpha1.ResourceNode, string) bool) error {
	ret := _m.Called(server, key, action)

	if len(ret) == 0 {
		panic("no return value specified for IterateHierarchy")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(*v1alpha1.Cluster, kube.ResourceKey, func(v1alpha1.ResourceNode, string) bool) error); ok {
		r0 = rf(server, key, action)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// LiveStateCache_IterateHierarchy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IterateHierarchy'
type LiveStateCache_IterateHierarchy_Call struct {
	*mock.Call
}

// IterateHierarchy is a helper method to define mock.On call
//   - server *v1alpha1.Cluster
//   - key kube.ResourceKey
//   - action func(v1alpha1.ResourceNode , string) bool
func (_e *LiveStateCache_Expecter) IterateHierarchy(server interface{}, key interface{}, action interface{}) *LiveStateCache_IterateHierarchy_Call {
	return &LiveStateCache_IterateHierarchy_Call{Call: _e.mock.On("IterateHierarchy", server, key, action)}
}

func (_c *LiveStateCache_IterateHierarchy_Call) Run(run func(server *v1alpha1.Cluster, key kube.ResourceKey, action func(v1alpha1.ResourceNode, string) bool)) *LiveStateCache_IterateHierarchy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*v1alpha1.Cluster), args[1].(kube.ResourceKey), args[2].(func(v1alpha1.ResourceNode, string) bool))
	})
	return _c
}

func (_c *LiveStateCache_IterateHierarchy_Call) Return(_a0 error) *LiveStateCache_IterateHierarchy_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *LiveStateCache_IterateHierarchy_Call) RunAndReturn(run func(*v1alpha1.Cluster, kube.ResourceKey, func(v1alpha1.ResourceNode, string) bool) error) *LiveStateCache_IterateHierarchy_Call {
	_c.Call.Return(run)
	return _c
}

// IterateHierarchyV2 provides a mock function with given fields: server, keys, action
func (_m *LiveStateCache) IterateHierarchyV2(server *v1alpha1.Cluster, keys []kube.ResourceKey, action func(v1alpha1.ResourceNode, string) bool) error {
	ret := _m.Called(server, keys, action)

	if len(ret) == 0 {
		panic("no return value specified for IterateHierarchyV2")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(*v1alpha1.Cluster, []kube.ResourceKey, func(v1alpha1.ResourceNode, string) bool) error); ok {
		r0 = rf(server, keys, action)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// LiveStateCache_IterateHierarchyV2_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IterateHierarchyV2'
type LiveStateCache_IterateHierarchyV2_Call struct {
	*mock.Call
}

// IterateHierarchyV2 is a helper method to define mock.On call
//   - server *v1alpha1.Cluster
//   - keys []kube.ResourceKey
//   - action func(v1alpha1.ResourceNode , string) bool
func (_e *LiveStateCache_Expecter) IterateHierarchyV2(server interface{}, keys interface{}, action interface{}) *LiveStateCache_IterateHierarchyV2_Call {
	return &LiveStateCache_IterateHierarchyV2_Call{Call: _e.mock.On("IterateHierarchyV2", server, keys, action)}
}

func (_c *LiveStateCache_IterateHierarchyV2_Call) Run(run func(server *v1alpha1.Cluster, keys []kube.ResourceKey, action func(v1alpha1.ResourceNode, string) bool)) *LiveStateCache_IterateHierarchyV2_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*v1alpha1.Cluster), args[1].([]kube.ResourceKey), args[2].(func(v1alpha1.ResourceNode, string) bool))
	})
	return _c
}

func (_c *LiveStateCache_IterateHierarchyV2_Call) Return(_a0 error) *LiveStateCache_IterateHierarchyV2_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *LiveStateCache_IterateHierarchyV2_Call) RunAndReturn(run func(*v1alpha1.Cluster, []kube.ResourceKey, func(v1alpha1.ResourceNode, string) bool) error) *LiveStateCache_IterateHierarchyV2_Call {
	_c.Call.Return(run)
	return _c
}

// IterateResources provides a mock function with given fields: server, callback
func (_m *LiveStateCache) IterateResources(server *v1alpha1.Cluster, callback func(*cache.Resource, *controllercache.ResourceInfo)) error {
	ret := _m.Called(server, callback)

	if len(ret) == 0 {
		panic("no return value specified for IterateResources")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(*v1alpha1.Cluster, func(*cache.Resource, *controllercache.ResourceInfo)) error); ok {
		r0 = rf(server, callback)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// LiveStateCache_IterateResources_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IterateResources'
type LiveStateCache_IterateResources_Call struct {
	*mock.Call
}

// IterateResources is a helper method to define mock.On call
//   - server *v1alpha1.Cluster
//   - callback func(*cache.Resource , *controllercache.ResourceInfo)
func (_e *LiveStateCache_Expecter) IterateResources(server interface{}, callback interface{}) *LiveStateCache_IterateResources_Call {
	return &LiveStateCache_IterateResources_Call{Call: _e.mock.On("IterateResources", server, callback)}
}

func (_c *LiveStateCache_IterateResources_Call) Run(run func(server *v1alpha1.Cluster, callback func(*cache.Resource, *controllercache.ResourceInfo))) *LiveStateCache_IterateResources_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*v1alpha1.Cluster), args[1].(func(*cache.Resource, *controllercache.ResourceInfo)))
	})
	return _c
}

func (_c *LiveStateCache_IterateResources_Call) Return(_a0 error) *LiveStateCache_IterateResources_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *LiveStateCache_IterateResources_Call) RunAndReturn(run func(*v1alpha1.Cluster, func(*cache.Resource, *controllercache.ResourceInfo)) error) *LiveStateCache_IterateResources_Call {
	_c.Call.Return(run)
	return _c
}

// Run provides a mock function with given fields: ctx
func (_m *LiveStateCache) Run(ctx context.Context) error {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Run")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context) error); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// LiveStateCache_Run_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Run'
type LiveStateCache_Run_Call struct {
	*mock.Call
}

// Run is a helper method to define mock.On call
//   - ctx context.Context
func (_e *LiveStateCache_Expecter) Run(ctx interface{}) *LiveStateCache_Run_Call {
	return &LiveStateCache_Run_Call{Call: _e.mock.On("Run", ctx)}
}

func (_c *LiveStateCache_Run_Call) Run(run func(ctx context.Context)) *LiveStateCache_Run_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *LiveStateCache_Run_Call) Return(_a0 error) *LiveStateCache_Run_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *LiveStateCache_Run_Call) RunAndReturn(run func(context.Context) error) *LiveStateCache_Run_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateShard provides a mock function with given fields: shard
func (_m *LiveStateCache) UpdateShard(shard int) bool {
	ret := _m.Called(shard)

	if len(ret) == 0 {
		panic("no return value specified for UpdateShard")
	}

	var r0 bool
	if rf, ok := ret.Get(0).(func(int) bool); ok {
		r0 = rf(shard)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// LiveStateCache_UpdateShard_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateShard'
type LiveStateCache_UpdateShard_Call struct {
	*mock.Call
}

// UpdateShard is a helper method to define mock.On call
//   - shard int
func (_e *LiveStateCache_Expecter) UpdateShard(shard interface{}) *LiveStateCache_UpdateShard_Call {
	return &LiveStateCache_UpdateShard_Call{Call: _e.mock.On("UpdateShard", shard)}
}

func (_c *LiveStateCache_UpdateShard_Call) Run(run func(shard int)) *LiveStateCache_UpdateShard_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(int))
	})
	return _c
}

func (_c *LiveStateCache_UpdateShard_Call) Return(_a0 bool) *LiveStateCache_UpdateShard_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *LiveStateCache_UpdateShard_Call) RunAndReturn(run func(int) bool) *LiveStateCache_UpdateShard_Call {
	_c.Call.Return(run)
	return _c
}

// NewLiveStateCache creates a new instance of LiveStateCache. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewLiveStateCache(t interface {
	mock.TestingT
	Cleanup(func())
}) *LiveStateCache {
	mock := &LiveStateCache{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
