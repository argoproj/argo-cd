// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package mocks

import (
	"github.com/argoproj/argo-cd/v3/util/git"
	mock "github.com/stretchr/testify/mock"
)

// NewClient creates a new instance of Client. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *Client {
	mock := &Client{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// Client is an autogenerated mock type for the Client type
type Client struct {
	mock.Mock
}

type Client_Expecter struct {
	mock *mock.Mock
}

func (_m *Client) EXPECT() *Client_Expecter {
	return &Client_Expecter{mock: &_m.Mock}
}

// ChangedFiles provides a mock function for the type Client
func (_mock *Client) ChangedFiles(revision string, targetRevision string) ([]string, error) {
	ret := _mock.Called(revision, targetRevision)

	if len(ret) == 0 {
		panic("no return value specified for ChangedFiles")
	}

	var r0 []string
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(string, string) ([]string, error)); ok {
		return returnFunc(revision, targetRevision)
	}
	if returnFunc, ok := ret.Get(0).(func(string, string) []string); ok {
		r0 = returnFunc(revision, targetRevision)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(string, string) error); ok {
		r1 = returnFunc(revision, targetRevision)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Client_ChangedFiles_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ChangedFiles'
type Client_ChangedFiles_Call struct {
	*mock.Call
}

// ChangedFiles is a helper method to define mock.On call
//   - revision
//   - targetRevision
func (_e *Client_Expecter) ChangedFiles(revision interface{}, targetRevision interface{}) *Client_ChangedFiles_Call {
	return &Client_ChangedFiles_Call{Call: _e.mock.On("ChangedFiles", revision, targetRevision)}
}

func (_c *Client_ChangedFiles_Call) Run(run func(revision string, targetRevision string)) *Client_ChangedFiles_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string))
	})
	return _c
}

func (_c *Client_ChangedFiles_Call) Return(strings []string, err error) *Client_ChangedFiles_Call {
	_c.Call.Return(strings, err)
	return _c
}

func (_c *Client_ChangedFiles_Call) RunAndReturn(run func(revision string, targetRevision string) ([]string, error)) *Client_ChangedFiles_Call {
	_c.Call.Return(run)
	return _c
}

// Checkout provides a mock function for the type Client
func (_mock *Client) Checkout(revision string, submoduleEnabled bool) (string, error) {
	ret := _mock.Called(revision, submoduleEnabled)

	if len(ret) == 0 {
		panic("no return value specified for Checkout")
	}

	var r0 string
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(string, bool) (string, error)); ok {
		return returnFunc(revision, submoduleEnabled)
	}
	if returnFunc, ok := ret.Get(0).(func(string, bool) string); ok {
		r0 = returnFunc(revision, submoduleEnabled)
	} else {
		r0 = ret.Get(0).(string)
	}
	if returnFunc, ok := ret.Get(1).(func(string, bool) error); ok {
		r1 = returnFunc(revision, submoduleEnabled)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Client_Checkout_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Checkout'
type Client_Checkout_Call struct {
	*mock.Call
}

// Checkout is a helper method to define mock.On call
//   - revision
//   - submoduleEnabled
func (_e *Client_Expecter) Checkout(revision interface{}, submoduleEnabled interface{}) *Client_Checkout_Call {
	return &Client_Checkout_Call{Call: _e.mock.On("Checkout", revision, submoduleEnabled)}
}

func (_c *Client_Checkout_Call) Run(run func(revision string, submoduleEnabled bool)) *Client_Checkout_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(bool))
	})
	return _c
}

func (_c *Client_Checkout_Call) Return(s string, err error) *Client_Checkout_Call {
	_c.Call.Return(s, err)
	return _c
}

func (_c *Client_Checkout_Call) RunAndReturn(run func(revision string, submoduleEnabled bool) (string, error)) *Client_Checkout_Call {
	_c.Call.Return(run)
	return _c
}

// CheckoutOrNew provides a mock function for the type Client
func (_mock *Client) CheckoutOrNew(branch string, base string, submoduleEnabled bool) (string, error) {
	ret := _mock.Called(branch, base, submoduleEnabled)

	if len(ret) == 0 {
		panic("no return value specified for CheckoutOrNew")
	}

	var r0 string
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(string, string, bool) (string, error)); ok {
		return returnFunc(branch, base, submoduleEnabled)
	}
	if returnFunc, ok := ret.Get(0).(func(string, string, bool) string); ok {
		r0 = returnFunc(branch, base, submoduleEnabled)
	} else {
		r0 = ret.Get(0).(string)
	}
	if returnFunc, ok := ret.Get(1).(func(string, string, bool) error); ok {
		r1 = returnFunc(branch, base, submoduleEnabled)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Client_CheckoutOrNew_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CheckoutOrNew'
type Client_CheckoutOrNew_Call struct {
	*mock.Call
}

// CheckoutOrNew is a helper method to define mock.On call
//   - branch
//   - base
//   - submoduleEnabled
func (_e *Client_Expecter) CheckoutOrNew(branch interface{}, base interface{}, submoduleEnabled interface{}) *Client_CheckoutOrNew_Call {
	return &Client_CheckoutOrNew_Call{Call: _e.mock.On("CheckoutOrNew", branch, base, submoduleEnabled)}
}

func (_c *Client_CheckoutOrNew_Call) Run(run func(branch string, base string, submoduleEnabled bool)) *Client_CheckoutOrNew_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string), args[2].(bool))
	})
	return _c
}

func (_c *Client_CheckoutOrNew_Call) Return(s string, err error) *Client_CheckoutOrNew_Call {
	_c.Call.Return(s, err)
	return _c
}

func (_c *Client_CheckoutOrNew_Call) RunAndReturn(run func(branch string, base string, submoduleEnabled bool) (string, error)) *Client_CheckoutOrNew_Call {
	_c.Call.Return(run)
	return _c
}

// CheckoutOrOrphan provides a mock function for the type Client
func (_mock *Client) CheckoutOrOrphan(branch string, submoduleEnabled bool) (string, error) {
	ret := _mock.Called(branch, submoduleEnabled)

	if len(ret) == 0 {
		panic("no return value specified for CheckoutOrOrphan")
	}

	var r0 string
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(string, bool) (string, error)); ok {
		return returnFunc(branch, submoduleEnabled)
	}
	if returnFunc, ok := ret.Get(0).(func(string, bool) string); ok {
		r0 = returnFunc(branch, submoduleEnabled)
	} else {
		r0 = ret.Get(0).(string)
	}
	if returnFunc, ok := ret.Get(1).(func(string, bool) error); ok {
		r1 = returnFunc(branch, submoduleEnabled)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Client_CheckoutOrOrphan_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CheckoutOrOrphan'
type Client_CheckoutOrOrphan_Call struct {
	*mock.Call
}

// CheckoutOrOrphan is a helper method to define mock.On call
//   - branch
//   - submoduleEnabled
func (_e *Client_Expecter) CheckoutOrOrphan(branch interface{}, submoduleEnabled interface{}) *Client_CheckoutOrOrphan_Call {
	return &Client_CheckoutOrOrphan_Call{Call: _e.mock.On("CheckoutOrOrphan", branch, submoduleEnabled)}
}

func (_c *Client_CheckoutOrOrphan_Call) Run(run func(branch string, submoduleEnabled bool)) *Client_CheckoutOrOrphan_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(bool))
	})
	return _c
}

func (_c *Client_CheckoutOrOrphan_Call) Return(s string, err error) *Client_CheckoutOrOrphan_Call {
	_c.Call.Return(s, err)
	return _c
}

func (_c *Client_CheckoutOrOrphan_Call) RunAndReturn(run func(branch string, submoduleEnabled bool) (string, error)) *Client_CheckoutOrOrphan_Call {
	_c.Call.Return(run)
	return _c
}

// CommitAndPush provides a mock function for the type Client
func (_mock *Client) CommitAndPush(branch string, message string) (string, error) {
	ret := _mock.Called(branch, message)

	if len(ret) == 0 {
		panic("no return value specified for CommitAndPush")
	}

	var r0 string
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(string, string) (string, error)); ok {
		return returnFunc(branch, message)
	}
	if returnFunc, ok := ret.Get(0).(func(string, string) string); ok {
		r0 = returnFunc(branch, message)
	} else {
		r0 = ret.Get(0).(string)
	}
	if returnFunc, ok := ret.Get(1).(func(string, string) error); ok {
		r1 = returnFunc(branch, message)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Client_CommitAndPush_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CommitAndPush'
type Client_CommitAndPush_Call struct {
	*mock.Call
}

// CommitAndPush is a helper method to define mock.On call
//   - branch
//   - message
func (_e *Client_Expecter) CommitAndPush(branch interface{}, message interface{}) *Client_CommitAndPush_Call {
	return &Client_CommitAndPush_Call{Call: _e.mock.On("CommitAndPush", branch, message)}
}

func (_c *Client_CommitAndPush_Call) Run(run func(branch string, message string)) *Client_CommitAndPush_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string))
	})
	return _c
}

func (_c *Client_CommitAndPush_Call) Return(s string, err error) *Client_CommitAndPush_Call {
	_c.Call.Return(s, err)
	return _c
}

func (_c *Client_CommitAndPush_Call) RunAndReturn(run func(branch string, message string) (string, error)) *Client_CommitAndPush_Call {
	_c.Call.Return(run)
	return _c
}

// CommitSHA provides a mock function for the type Client
func (_mock *Client) CommitSHA() (string, error) {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for CommitSHA")
	}

	var r0 string
	var r1 error
	if returnFunc, ok := ret.Get(0).(func() (string, error)); ok {
		return returnFunc()
	}
	if returnFunc, ok := ret.Get(0).(func() string); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(string)
	}
	if returnFunc, ok := ret.Get(1).(func() error); ok {
		r1 = returnFunc()
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Client_CommitSHA_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CommitSHA'
type Client_CommitSHA_Call struct {
	*mock.Call
}

// CommitSHA is a helper method to define mock.On call
func (_e *Client_Expecter) CommitSHA() *Client_CommitSHA_Call {
	return &Client_CommitSHA_Call{Call: _e.mock.On("CommitSHA")}
}

func (_c *Client_CommitSHA_Call) Run(run func()) *Client_CommitSHA_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Client_CommitSHA_Call) Return(s string, err error) *Client_CommitSHA_Call {
	_c.Call.Return(s, err)
	return _c
}

func (_c *Client_CommitSHA_Call) RunAndReturn(run func() (string, error)) *Client_CommitSHA_Call {
	_c.Call.Return(run)
	return _c
}

// Fetch provides a mock function for the type Client
func (_mock *Client) Fetch(revision string) error {
	ret := _mock.Called(revision)

	if len(ret) == 0 {
		panic("no return value specified for Fetch")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(string) error); ok {
		r0 = returnFunc(revision)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Client_Fetch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Fetch'
type Client_Fetch_Call struct {
	*mock.Call
}

// Fetch is a helper method to define mock.On call
//   - revision
func (_e *Client_Expecter) Fetch(revision interface{}) *Client_Fetch_Call {
	return &Client_Fetch_Call{Call: _e.mock.On("Fetch", revision)}
}

func (_c *Client_Fetch_Call) Run(run func(revision string)) *Client_Fetch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Client_Fetch_Call) Return(err error) *Client_Fetch_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Client_Fetch_Call) RunAndReturn(run func(revision string) error) *Client_Fetch_Call {
	_c.Call.Return(run)
	return _c
}

// Init provides a mock function for the type Client
func (_mock *Client) Init() error {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Init")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func() error); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Client_Init_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Init'
type Client_Init_Call struct {
	*mock.Call
}

// Init is a helper method to define mock.On call
func (_e *Client_Expecter) Init() *Client_Init_Call {
	return &Client_Init_Call{Call: _e.mock.On("Init")}
}

func (_c *Client_Init_Call) Run(run func()) *Client_Init_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Client_Init_Call) Return(err error) *Client_Init_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Client_Init_Call) RunAndReturn(run func() error) *Client_Init_Call {
	_c.Call.Return(run)
	return _c
}

// IsAnnotatedTag provides a mock function for the type Client
func (_mock *Client) IsAnnotatedTag(s string) bool {
	ret := _mock.Called(s)

	if len(ret) == 0 {
		panic("no return value specified for IsAnnotatedTag")
	}

	var r0 bool
	if returnFunc, ok := ret.Get(0).(func(string) bool); ok {
		r0 = returnFunc(s)
	} else {
		r0 = ret.Get(0).(bool)
	}
	return r0
}

// Client_IsAnnotatedTag_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IsAnnotatedTag'
type Client_IsAnnotatedTag_Call struct {
	*mock.Call
}

// IsAnnotatedTag is a helper method to define mock.On call
//   - s
func (_e *Client_Expecter) IsAnnotatedTag(s interface{}) *Client_IsAnnotatedTag_Call {
	return &Client_IsAnnotatedTag_Call{Call: _e.mock.On("IsAnnotatedTag", s)}
}

func (_c *Client_IsAnnotatedTag_Call) Run(run func(s string)) *Client_IsAnnotatedTag_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Client_IsAnnotatedTag_Call) Return(b bool) *Client_IsAnnotatedTag_Call {
	_c.Call.Return(b)
	return _c
}

func (_c *Client_IsAnnotatedTag_Call) RunAndReturn(run func(s string) bool) *Client_IsAnnotatedTag_Call {
	_c.Call.Return(run)
	return _c
}

// IsRevisionPresent provides a mock function for the type Client
func (_mock *Client) IsRevisionPresent(revision string) bool {
	ret := _mock.Called(revision)

	if len(ret) == 0 {
		panic("no return value specified for IsRevisionPresent")
	}

	var r0 bool
	if returnFunc, ok := ret.Get(0).(func(string) bool); ok {
		r0 = returnFunc(revision)
	} else {
		r0 = ret.Get(0).(bool)
	}
	return r0
}

// Client_IsRevisionPresent_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IsRevisionPresent'
type Client_IsRevisionPresent_Call struct {
	*mock.Call
}

// IsRevisionPresent is a helper method to define mock.On call
//   - revision
func (_e *Client_Expecter) IsRevisionPresent(revision interface{}) *Client_IsRevisionPresent_Call {
	return &Client_IsRevisionPresent_Call{Call: _e.mock.On("IsRevisionPresent", revision)}
}

func (_c *Client_IsRevisionPresent_Call) Run(run func(revision string)) *Client_IsRevisionPresent_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Client_IsRevisionPresent_Call) Return(b bool) *Client_IsRevisionPresent_Call {
	_c.Call.Return(b)
	return _c
}

func (_c *Client_IsRevisionPresent_Call) RunAndReturn(run func(revision string) bool) *Client_IsRevisionPresent_Call {
	_c.Call.Return(run)
	return _c
}

// LsFiles provides a mock function for the type Client
func (_mock *Client) LsFiles(path string, enableNewGitFileGlobbing bool) ([]string, error) {
	ret := _mock.Called(path, enableNewGitFileGlobbing)

	if len(ret) == 0 {
		panic("no return value specified for LsFiles")
	}

	var r0 []string
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(string, bool) ([]string, error)); ok {
		return returnFunc(path, enableNewGitFileGlobbing)
	}
	if returnFunc, ok := ret.Get(0).(func(string, bool) []string); ok {
		r0 = returnFunc(path, enableNewGitFileGlobbing)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(string, bool) error); ok {
		r1 = returnFunc(path, enableNewGitFileGlobbing)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Client_LsFiles_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LsFiles'
type Client_LsFiles_Call struct {
	*mock.Call
}

// LsFiles is a helper method to define mock.On call
//   - path
//   - enableNewGitFileGlobbing
func (_e *Client_Expecter) LsFiles(path interface{}, enableNewGitFileGlobbing interface{}) *Client_LsFiles_Call {
	return &Client_LsFiles_Call{Call: _e.mock.On("LsFiles", path, enableNewGitFileGlobbing)}
}

func (_c *Client_LsFiles_Call) Run(run func(path string, enableNewGitFileGlobbing bool)) *Client_LsFiles_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(bool))
	})
	return _c
}

func (_c *Client_LsFiles_Call) Return(strings []string, err error) *Client_LsFiles_Call {
	_c.Call.Return(strings, err)
	return _c
}

func (_c *Client_LsFiles_Call) RunAndReturn(run func(path string, enableNewGitFileGlobbing bool) ([]string, error)) *Client_LsFiles_Call {
	_c.Call.Return(run)
	return _c
}

// LsLargeFiles provides a mock function for the type Client
func (_mock *Client) LsLargeFiles() ([]string, error) {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for LsLargeFiles")
	}

	var r0 []string
	var r1 error
	if returnFunc, ok := ret.Get(0).(func() ([]string, error)); ok {
		return returnFunc()
	}
	if returnFunc, ok := ret.Get(0).(func() []string); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}
	if returnFunc, ok := ret.Get(1).(func() error); ok {
		r1 = returnFunc()
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Client_LsLargeFiles_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LsLargeFiles'
type Client_LsLargeFiles_Call struct {
	*mock.Call
}

// LsLargeFiles is a helper method to define mock.On call
func (_e *Client_Expecter) LsLargeFiles() *Client_LsLargeFiles_Call {
	return &Client_LsLargeFiles_Call{Call: _e.mock.On("LsLargeFiles")}
}

func (_c *Client_LsLargeFiles_Call) Run(run func()) *Client_LsLargeFiles_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Client_LsLargeFiles_Call) Return(strings []string, err error) *Client_LsLargeFiles_Call {
	_c.Call.Return(strings, err)
	return _c
}

func (_c *Client_LsLargeFiles_Call) RunAndReturn(run func() ([]string, error)) *Client_LsLargeFiles_Call {
	_c.Call.Return(run)
	return _c
}

// LsRefs provides a mock function for the type Client
func (_mock *Client) LsRefs() (*git.Refs, error) {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for LsRefs")
	}

	var r0 *git.Refs
	var r1 error
	if returnFunc, ok := ret.Get(0).(func() (*git.Refs, error)); ok {
		return returnFunc()
	}
	if returnFunc, ok := ret.Get(0).(func() *git.Refs); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*git.Refs)
		}
	}
	if returnFunc, ok := ret.Get(1).(func() error); ok {
		r1 = returnFunc()
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Client_LsRefs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LsRefs'
type Client_LsRefs_Call struct {
	*mock.Call
}

// LsRefs is a helper method to define mock.On call
func (_e *Client_Expecter) LsRefs() *Client_LsRefs_Call {
	return &Client_LsRefs_Call{Call: _e.mock.On("LsRefs")}
}

func (_c *Client_LsRefs_Call) Run(run func()) *Client_LsRefs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Client_LsRefs_Call) Return(refs *git.Refs, err error) *Client_LsRefs_Call {
	_c.Call.Return(refs, err)
	return _c
}

func (_c *Client_LsRefs_Call) RunAndReturn(run func() (*git.Refs, error)) *Client_LsRefs_Call {
	_c.Call.Return(run)
	return _c
}

// LsRemote provides a mock function for the type Client
func (_mock *Client) LsRemote(revision string) (string, error) {
	ret := _mock.Called(revision)

	if len(ret) == 0 {
		panic("no return value specified for LsRemote")
	}

	var r0 string
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(string) (string, error)); ok {
		return returnFunc(revision)
	}
	if returnFunc, ok := ret.Get(0).(func(string) string); ok {
		r0 = returnFunc(revision)
	} else {
		r0 = ret.Get(0).(string)
	}
	if returnFunc, ok := ret.Get(1).(func(string) error); ok {
		r1 = returnFunc(revision)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Client_LsRemote_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LsRemote'
type Client_LsRemote_Call struct {
	*mock.Call
}

// LsRemote is a helper method to define mock.On call
//   - revision
func (_e *Client_Expecter) LsRemote(revision interface{}) *Client_LsRemote_Call {
	return &Client_LsRemote_Call{Call: _e.mock.On("LsRemote", revision)}
}

func (_c *Client_LsRemote_Call) Run(run func(revision string)) *Client_LsRemote_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Client_LsRemote_Call) Return(s string, err error) *Client_LsRemote_Call {
	_c.Call.Return(s, err)
	return _c
}

func (_c *Client_LsRemote_Call) RunAndReturn(run func(revision string) (string, error)) *Client_LsRemote_Call {
	_c.Call.Return(run)
	return _c
}

// RemoveContents provides a mock function for the type Client
func (_mock *Client) RemoveContents() (string, error) {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for RemoveContents")
	}

	var r0 string
	var r1 error
	if returnFunc, ok := ret.Get(0).(func() (string, error)); ok {
		return returnFunc()
	}
	if returnFunc, ok := ret.Get(0).(func() string); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(string)
	}
	if returnFunc, ok := ret.Get(1).(func() error); ok {
		r1 = returnFunc()
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Client_RemoveContents_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoveContents'
type Client_RemoveContents_Call struct {
	*mock.Call
}

// RemoveContents is a helper method to define mock.On call
func (_e *Client_Expecter) RemoveContents() *Client_RemoveContents_Call {
	return &Client_RemoveContents_Call{Call: _e.mock.On("RemoveContents")}
}

func (_c *Client_RemoveContents_Call) Run(run func()) *Client_RemoveContents_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Client_RemoveContents_Call) Return(s string, err error) *Client_RemoveContents_Call {
	_c.Call.Return(s, err)
	return _c
}

func (_c *Client_RemoveContents_Call) RunAndReturn(run func() (string, error)) *Client_RemoveContents_Call {
	_c.Call.Return(run)
	return _c
}

// RevisionMetadata provides a mock function for the type Client
func (_mock *Client) RevisionMetadata(revision string) (*git.RevisionMetadata, error) {
	ret := _mock.Called(revision)

	if len(ret) == 0 {
		panic("no return value specified for RevisionMetadata")
	}

	var r0 *git.RevisionMetadata
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(string) (*git.RevisionMetadata, error)); ok {
		return returnFunc(revision)
	}
	if returnFunc, ok := ret.Get(0).(func(string) *git.RevisionMetadata); ok {
		r0 = returnFunc(revision)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*git.RevisionMetadata)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(string) error); ok {
		r1 = returnFunc(revision)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Client_RevisionMetadata_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RevisionMetadata'
type Client_RevisionMetadata_Call struct {
	*mock.Call
}

// RevisionMetadata is a helper method to define mock.On call
//   - revision
func (_e *Client_Expecter) RevisionMetadata(revision interface{}) *Client_RevisionMetadata_Call {
	return &Client_RevisionMetadata_Call{Call: _e.mock.On("RevisionMetadata", revision)}
}

func (_c *Client_RevisionMetadata_Call) Run(run func(revision string)) *Client_RevisionMetadata_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Client_RevisionMetadata_Call) Return(revisionMetadata *git.RevisionMetadata, err error) *Client_RevisionMetadata_Call {
	_c.Call.Return(revisionMetadata, err)
	return _c
}

func (_c *Client_RevisionMetadata_Call) RunAndReturn(run func(revision string) (*git.RevisionMetadata, error)) *Client_RevisionMetadata_Call {
	_c.Call.Return(run)
	return _c
}

// Root provides a mock function for the type Client
func (_mock *Client) Root() string {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Root")
	}

	var r0 string
	if returnFunc, ok := ret.Get(0).(func() string); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(string)
	}
	return r0
}

// Client_Root_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Root'
type Client_Root_Call struct {
	*mock.Call
}

// Root is a helper method to define mock.On call
func (_e *Client_Expecter) Root() *Client_Root_Call {
	return &Client_Root_Call{Call: _e.mock.On("Root")}
}

func (_c *Client_Root_Call) Run(run func()) *Client_Root_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Client_Root_Call) Return(s string) *Client_Root_Call {
	_c.Call.Return(s)
	return _c
}

func (_c *Client_Root_Call) RunAndReturn(run func() string) *Client_Root_Call {
	_c.Call.Return(run)
	return _c
}

// SetAuthor provides a mock function for the type Client
func (_mock *Client) SetAuthor(name string, email string) (string, error) {
	ret := _mock.Called(name, email)

	if len(ret) == 0 {
		panic("no return value specified for SetAuthor")
	}

	var r0 string
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(string, string) (string, error)); ok {
		return returnFunc(name, email)
	}
	if returnFunc, ok := ret.Get(0).(func(string, string) string); ok {
		r0 = returnFunc(name, email)
	} else {
		r0 = ret.Get(0).(string)
	}
	if returnFunc, ok := ret.Get(1).(func(string, string) error); ok {
		r1 = returnFunc(name, email)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Client_SetAuthor_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetAuthor'
type Client_SetAuthor_Call struct {
	*mock.Call
}

// SetAuthor is a helper method to define mock.On call
//   - name
//   - email
func (_e *Client_Expecter) SetAuthor(name interface{}, email interface{}) *Client_SetAuthor_Call {
	return &Client_SetAuthor_Call{Call: _e.mock.On("SetAuthor", name, email)}
}

func (_c *Client_SetAuthor_Call) Run(run func(name string, email string)) *Client_SetAuthor_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string))
	})
	return _c
}

func (_c *Client_SetAuthor_Call) Return(s string, err error) *Client_SetAuthor_Call {
	_c.Call.Return(s, err)
	return _c
}

func (_c *Client_SetAuthor_Call) RunAndReturn(run func(name string, email string) (string, error)) *Client_SetAuthor_Call {
	_c.Call.Return(run)
	return _c
}

// Submodule provides a mock function for the type Client
func (_mock *Client) Submodule() error {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Submodule")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func() error); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Client_Submodule_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Submodule'
type Client_Submodule_Call struct {
	*mock.Call
}

// Submodule is a helper method to define mock.On call
func (_e *Client_Expecter) Submodule() *Client_Submodule_Call {
	return &Client_Submodule_Call{Call: _e.mock.On("Submodule")}
}

func (_c *Client_Submodule_Call) Run(run func()) *Client_Submodule_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Client_Submodule_Call) Return(err error) *Client_Submodule_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Client_Submodule_Call) RunAndReturn(run func() error) *Client_Submodule_Call {
	_c.Call.Return(run)
	return _c
}

// VerifyCommitSignature provides a mock function for the type Client
func (_mock *Client) VerifyCommitSignature(s string) (string, error) {
	ret := _mock.Called(s)

	if len(ret) == 0 {
		panic("no return value specified for VerifyCommitSignature")
	}

	var r0 string
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(string) (string, error)); ok {
		return returnFunc(s)
	}
	if returnFunc, ok := ret.Get(0).(func(string) string); ok {
		r0 = returnFunc(s)
	} else {
		r0 = ret.Get(0).(string)
	}
	if returnFunc, ok := ret.Get(1).(func(string) error); ok {
		r1 = returnFunc(s)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Client_VerifyCommitSignature_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'VerifyCommitSignature'
type Client_VerifyCommitSignature_Call struct {
	*mock.Call
}

// VerifyCommitSignature is a helper method to define mock.On call
//   - s
func (_e *Client_Expecter) VerifyCommitSignature(s interface{}) *Client_VerifyCommitSignature_Call {
	return &Client_VerifyCommitSignature_Call{Call: _e.mock.On("VerifyCommitSignature", s)}
}

func (_c *Client_VerifyCommitSignature_Call) Run(run func(s string)) *Client_VerifyCommitSignature_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Client_VerifyCommitSignature_Call) Return(s1 string, err error) *Client_VerifyCommitSignature_Call {
	_c.Call.Return(s1, err)
	return _c
}

func (_c *Client_VerifyCommitSignature_Call) RunAndReturn(run func(s string) (string, error)) *Client_VerifyCommitSignature_Call {
	_c.Call.Return(run)
	return _c
}
