// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package mocks

import (
	"context"

	"github.com/argoproj/argo-cd/v3/pkg/apis/application/v1alpha1"
	"github.com/argoproj/argo-cd/v3/util/db"
	mock "github.com/stretchr/testify/mock"
)

// NewArgoDB creates a new instance of ArgoDB. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewArgoDB(t interface {
	mock.TestingT
	Cleanup(func())
}) *ArgoDB {
	mock := &ArgoDB{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// ArgoDB is an autogenerated mock type for the ArgoDB type
type ArgoDB struct {
	mock.Mock
}

type ArgoDB_Expecter struct {
	mock *mock.Mock
}

func (_m *ArgoDB) EXPECT() *ArgoDB_Expecter {
	return &ArgoDB_Expecter{mock: &_m.Mock}
}

// AddGPGPublicKey provides a mock function for the type ArgoDB
func (_mock *ArgoDB) AddGPGPublicKey(ctx context.Context, keyData string) (map[string]*v1alpha1.GnuPGPublicKey, []string, error) {
	ret := _mock.Called(ctx, keyData)

	if len(ret) == 0 {
		panic("no return value specified for AddGPGPublicKey")
	}

	var r0 map[string]*v1alpha1.GnuPGPublicKey
	var r1 []string
	var r2 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (map[string]*v1alpha1.GnuPGPublicKey, []string, error)); ok {
		return returnFunc(ctx, keyData)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) map[string]*v1alpha1.GnuPGPublicKey); ok {
		r0 = returnFunc(ctx, keyData)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]*v1alpha1.GnuPGPublicKey)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) []string); ok {
		r1 = returnFunc(ctx, keyData)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).([]string)
		}
	}
	if returnFunc, ok := ret.Get(2).(func(context.Context, string) error); ok {
		r2 = returnFunc(ctx, keyData)
	} else {
		r2 = ret.Error(2)
	}
	return r0, r1, r2
}

// ArgoDB_AddGPGPublicKey_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddGPGPublicKey'
type ArgoDB_AddGPGPublicKey_Call struct {
	*mock.Call
}

// AddGPGPublicKey is a helper method to define mock.On call
//   - ctx context.Context
//   - keyData string
func (_e *ArgoDB_Expecter) AddGPGPublicKey(ctx interface{}, keyData interface{}) *ArgoDB_AddGPGPublicKey_Call {
	return &ArgoDB_AddGPGPublicKey_Call{Call: _e.mock.On("AddGPGPublicKey", ctx, keyData)}
}

func (_c *ArgoDB_AddGPGPublicKey_Call) Run(run func(ctx context.Context, keyData string)) *ArgoDB_AddGPGPublicKey_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *ArgoDB_AddGPGPublicKey_Call) Return(stringToGnuPGPublicKey map[string]*v1alpha1.GnuPGPublicKey, strings []string, err error) *ArgoDB_AddGPGPublicKey_Call {
	_c.Call.Return(stringToGnuPGPublicKey, strings, err)
	return _c
}

func (_c *ArgoDB_AddGPGPublicKey_Call) RunAndReturn(run func(ctx context.Context, keyData string) (map[string]*v1alpha1.GnuPGPublicKey, []string, error)) *ArgoDB_AddGPGPublicKey_Call {
	_c.Call.Return(run)
	return _c
}

// CreateCluster provides a mock function for the type ArgoDB
func (_mock *ArgoDB) CreateCluster(ctx context.Context, c *v1alpha1.Cluster) (*v1alpha1.Cluster, error) {
	ret := _mock.Called(ctx, c)

	if len(ret) == 0 {
		panic("no return value specified for CreateCluster")
	}

	var r0 *v1alpha1.Cluster
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *v1alpha1.Cluster) (*v1alpha1.Cluster, error)); ok {
		return returnFunc(ctx, c)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *v1alpha1.Cluster) *v1alpha1.Cluster); ok {
		r0 = returnFunc(ctx, c)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*v1alpha1.Cluster)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *v1alpha1.Cluster) error); ok {
		r1 = returnFunc(ctx, c)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ArgoDB_CreateCluster_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateCluster'
type ArgoDB_CreateCluster_Call struct {
	*mock.Call
}

// CreateCluster is a helper method to define mock.On call
//   - ctx context.Context
//   - c *v1alpha1.Cluster
func (_e *ArgoDB_Expecter) CreateCluster(ctx interface{}, c interface{}) *ArgoDB_CreateCluster_Call {
	return &ArgoDB_CreateCluster_Call{Call: _e.mock.On("CreateCluster", ctx, c)}
}

func (_c *ArgoDB_CreateCluster_Call) Run(run func(ctx context.Context, c *v1alpha1.Cluster)) *ArgoDB_CreateCluster_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *v1alpha1.Cluster
		if args[1] != nil {
			arg1 = args[1].(*v1alpha1.Cluster)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *ArgoDB_CreateCluster_Call) Return(cluster *v1alpha1.Cluster, err error) *ArgoDB_CreateCluster_Call {
	_c.Call.Return(cluster, err)
	return _c
}

func (_c *ArgoDB_CreateCluster_Call) RunAndReturn(run func(ctx context.Context, c *v1alpha1.Cluster) (*v1alpha1.Cluster, error)) *ArgoDB_CreateCluster_Call {
	_c.Call.Return(run)
	return _c
}

// CreateRepoCertificate provides a mock function for the type ArgoDB
func (_mock *ArgoDB) CreateRepoCertificate(ctx context.Context, certificate *v1alpha1.RepositoryCertificateList, upsert bool) (*v1alpha1.RepositoryCertificateList, error) {
	ret := _mock.Called(ctx, certificate, upsert)

	if len(ret) == 0 {
		panic("no return value specified for CreateRepoCertificate")
	}

	var r0 *v1alpha1.RepositoryCertificateList
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *v1alpha1.RepositoryCertificateList, bool) (*v1alpha1.RepositoryCertificateList, error)); ok {
		return returnFunc(ctx, certificate, upsert)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *v1alpha1.RepositoryCertificateList, bool) *v1alpha1.RepositoryCertificateList); ok {
		r0 = returnFunc(ctx, certificate, upsert)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*v1alpha1.RepositoryCertificateList)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *v1alpha1.RepositoryCertificateList, bool) error); ok {
		r1 = returnFunc(ctx, certificate, upsert)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ArgoDB_CreateRepoCertificate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateRepoCertificate'
type ArgoDB_CreateRepoCertificate_Call struct {
	*mock.Call
}

// CreateRepoCertificate is a helper method to define mock.On call
//   - ctx context.Context
//   - certificate *v1alpha1.RepositoryCertificateList
//   - upsert bool
func (_e *ArgoDB_Expecter) CreateRepoCertificate(ctx interface{}, certificate interface{}, upsert interface{}) *ArgoDB_CreateRepoCertificate_Call {
	return &ArgoDB_CreateRepoCertificate_Call{Call: _e.mock.On("CreateRepoCertificate", ctx, certificate, upsert)}
}

func (_c *ArgoDB_CreateRepoCertificate_Call) Run(run func(ctx context.Context, certificate *v1alpha1.RepositoryCertificateList, upsert bool)) *ArgoDB_CreateRepoCertificate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *v1alpha1.RepositoryCertificateList
		if args[1] != nil {
			arg1 = args[1].(*v1alpha1.RepositoryCertificateList)
		}
		var arg2 bool
		if args[2] != nil {
			arg2 = args[2].(bool)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *ArgoDB_CreateRepoCertificate_Call) Return(repositoryCertificateList *v1alpha1.RepositoryCertificateList, err error) *ArgoDB_CreateRepoCertificate_Call {
	_c.Call.Return(repositoryCertificateList, err)
	return _c
}

func (_c *ArgoDB_CreateRepoCertificate_Call) RunAndReturn(run func(ctx context.Context, certificate *v1alpha1.RepositoryCertificateList, upsert bool) (*v1alpha1.RepositoryCertificateList, error)) *ArgoDB_CreateRepoCertificate_Call {
	_c.Call.Return(run)
	return _c
}

// CreateRepository provides a mock function for the type ArgoDB
func (_mock *ArgoDB) CreateRepository(ctx context.Context, r *v1alpha1.Repository) (*v1alpha1.Repository, error) {
	ret := _mock.Called(ctx, r)

	if len(ret) == 0 {
		panic("no return value specified for CreateRepository")
	}

	var r0 *v1alpha1.Repository
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *v1alpha1.Repository) (*v1alpha1.Repository, error)); ok {
		return returnFunc(ctx, r)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *v1alpha1.Repository) *v1alpha1.Repository); ok {
		r0 = returnFunc(ctx, r)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*v1alpha1.Repository)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *v1alpha1.Repository) error); ok {
		r1 = returnFunc(ctx, r)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ArgoDB_CreateRepository_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateRepository'
type ArgoDB_CreateRepository_Call struct {
	*mock.Call
}

// CreateRepository is a helper method to define mock.On call
//   - ctx context.Context
//   - r *v1alpha1.Repository
func (_e *ArgoDB_Expecter) CreateRepository(ctx interface{}, r interface{}) *ArgoDB_CreateRepository_Call {
	return &ArgoDB_CreateRepository_Call{Call: _e.mock.On("CreateRepository", ctx, r)}
}

func (_c *ArgoDB_CreateRepository_Call) Run(run func(ctx context.Context, r *v1alpha1.Repository)) *ArgoDB_CreateRepository_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *v1alpha1.Repository
		if args[1] != nil {
			arg1 = args[1].(*v1alpha1.Repository)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *ArgoDB_CreateRepository_Call) Return(repository *v1alpha1.Repository, err error) *ArgoDB_CreateRepository_Call {
	_c.Call.Return(repository, err)
	return _c
}

func (_c *ArgoDB_CreateRepository_Call) RunAndReturn(run func(ctx context.Context, r *v1alpha1.Repository) (*v1alpha1.Repository, error)) *ArgoDB_CreateRepository_Call {
	_c.Call.Return(run)
	return _c
}

// CreateRepositoryCredentials provides a mock function for the type ArgoDB
func (_mock *ArgoDB) CreateRepositoryCredentials(ctx context.Context, r *v1alpha1.RepoCreds) (*v1alpha1.RepoCreds, error) {
	ret := _mock.Called(ctx, r)

	if len(ret) == 0 {
		panic("no return value specified for CreateRepositoryCredentials")
	}

	var r0 *v1alpha1.RepoCreds
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *v1alpha1.RepoCreds) (*v1alpha1.RepoCreds, error)); ok {
		return returnFunc(ctx, r)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *v1alpha1.RepoCreds) *v1alpha1.RepoCreds); ok {
		r0 = returnFunc(ctx, r)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*v1alpha1.RepoCreds)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *v1alpha1.RepoCreds) error); ok {
		r1 = returnFunc(ctx, r)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ArgoDB_CreateRepositoryCredentials_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateRepositoryCredentials'
type ArgoDB_CreateRepositoryCredentials_Call struct {
	*mock.Call
}

// CreateRepositoryCredentials is a helper method to define mock.On call
//   - ctx context.Context
//   - r *v1alpha1.RepoCreds
func (_e *ArgoDB_Expecter) CreateRepositoryCredentials(ctx interface{}, r interface{}) *ArgoDB_CreateRepositoryCredentials_Call {
	return &ArgoDB_CreateRepositoryCredentials_Call{Call: _e.mock.On("CreateRepositoryCredentials", ctx, r)}
}

func (_c *ArgoDB_CreateRepositoryCredentials_Call) Run(run func(ctx context.Context, r *v1alpha1.RepoCreds)) *ArgoDB_CreateRepositoryCredentials_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *v1alpha1.RepoCreds
		if args[1] != nil {
			arg1 = args[1].(*v1alpha1.RepoCreds)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *ArgoDB_CreateRepositoryCredentials_Call) Return(repoCreds *v1alpha1.RepoCreds, err error) *ArgoDB_CreateRepositoryCredentials_Call {
	_c.Call.Return(repoCreds, err)
	return _c
}

func (_c *ArgoDB_CreateRepositoryCredentials_Call) RunAndReturn(run func(ctx context.Context, r *v1alpha1.RepoCreds) (*v1alpha1.RepoCreds, error)) *ArgoDB_CreateRepositoryCredentials_Call {
	_c.Call.Return(run)
	return _c
}

// CreateWriteRepository provides a mock function for the type ArgoDB
func (_mock *ArgoDB) CreateWriteRepository(ctx context.Context, r *v1alpha1.Repository) (*v1alpha1.Repository, error) {
	ret := _mock.Called(ctx, r)

	if len(ret) == 0 {
		panic("no return value specified for CreateWriteRepository")
	}

	var r0 *v1alpha1.Repository
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *v1alpha1.Repository) (*v1alpha1.Repository, error)); ok {
		return returnFunc(ctx, r)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *v1alpha1.Repository) *v1alpha1.Repository); ok {
		r0 = returnFunc(ctx, r)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*v1alpha1.Repository)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *v1alpha1.Repository) error); ok {
		r1 = returnFunc(ctx, r)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ArgoDB_CreateWriteRepository_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateWriteRepository'
type ArgoDB_CreateWriteRepository_Call struct {
	*mock.Call
}

// CreateWriteRepository is a helper method to define mock.On call
//   - ctx context.Context
//   - r *v1alpha1.Repository
func (_e *ArgoDB_Expecter) CreateWriteRepository(ctx interface{}, r interface{}) *ArgoDB_CreateWriteRepository_Call {
	return &ArgoDB_CreateWriteRepository_Call{Call: _e.mock.On("CreateWriteRepository", ctx, r)}
}

func (_c *ArgoDB_CreateWriteRepository_Call) Run(run func(ctx context.Context, r *v1alpha1.Repository)) *ArgoDB_CreateWriteRepository_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *v1alpha1.Repository
		if args[1] != nil {
			arg1 = args[1].(*v1alpha1.Repository)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *ArgoDB_CreateWriteRepository_Call) Return(repository *v1alpha1.Repository, err error) *ArgoDB_CreateWriteRepository_Call {
	_c.Call.Return(repository, err)
	return _c
}

func (_c *ArgoDB_CreateWriteRepository_Call) RunAndReturn(run func(ctx context.Context, r *v1alpha1.Repository) (*v1alpha1.Repository, error)) *ArgoDB_CreateWriteRepository_Call {
	_c.Call.Return(run)
	return _c
}

// CreateWriteRepositoryCredentials provides a mock function for the type ArgoDB
func (_mock *ArgoDB) CreateWriteRepositoryCredentials(ctx context.Context, r *v1alpha1.RepoCreds) (*v1alpha1.RepoCreds, error) {
	ret := _mock.Called(ctx, r)

	if len(ret) == 0 {
		panic("no return value specified for CreateWriteRepositoryCredentials")
	}

	var r0 *v1alpha1.RepoCreds
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *v1alpha1.RepoCreds) (*v1alpha1.RepoCreds, error)); ok {
		return returnFunc(ctx, r)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *v1alpha1.RepoCreds) *v1alpha1.RepoCreds); ok {
		r0 = returnFunc(ctx, r)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*v1alpha1.RepoCreds)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *v1alpha1.RepoCreds) error); ok {
		r1 = returnFunc(ctx, r)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ArgoDB_CreateWriteRepositoryCredentials_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateWriteRepositoryCredentials'
type ArgoDB_CreateWriteRepositoryCredentials_Call struct {
	*mock.Call
}

// CreateWriteRepositoryCredentials is a helper method to define mock.On call
//   - ctx context.Context
//   - r *v1alpha1.RepoCreds
func (_e *ArgoDB_Expecter) CreateWriteRepositoryCredentials(ctx interface{}, r interface{}) *ArgoDB_CreateWriteRepositoryCredentials_Call {
	return &ArgoDB_CreateWriteRepositoryCredentials_Call{Call: _e.mock.On("CreateWriteRepositoryCredentials", ctx, r)}
}

func (_c *ArgoDB_CreateWriteRepositoryCredentials_Call) Run(run func(ctx context.Context, r *v1alpha1.RepoCreds)) *ArgoDB_CreateWriteRepositoryCredentials_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *v1alpha1.RepoCreds
		if args[1] != nil {
			arg1 = args[1].(*v1alpha1.RepoCreds)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *ArgoDB_CreateWriteRepositoryCredentials_Call) Return(repoCreds *v1alpha1.RepoCreds, err error) *ArgoDB_CreateWriteRepositoryCredentials_Call {
	_c.Call.Return(repoCreds, err)
	return _c
}

func (_c *ArgoDB_CreateWriteRepositoryCredentials_Call) RunAndReturn(run func(ctx context.Context, r *v1alpha1.RepoCreds) (*v1alpha1.RepoCreds, error)) *ArgoDB_CreateWriteRepositoryCredentials_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteCluster provides a mock function for the type ArgoDB
func (_mock *ArgoDB) DeleteCluster(ctx context.Context, server string) error {
	ret := _mock.Called(ctx, server)

	if len(ret) == 0 {
		panic("no return value specified for DeleteCluster")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = returnFunc(ctx, server)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// ArgoDB_DeleteCluster_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteCluster'
type ArgoDB_DeleteCluster_Call struct {
	*mock.Call
}

// DeleteCluster is a helper method to define mock.On call
//   - ctx context.Context
//   - server string
func (_e *ArgoDB_Expecter) DeleteCluster(ctx interface{}, server interface{}) *ArgoDB_DeleteCluster_Call {
	return &ArgoDB_DeleteCluster_Call{Call: _e.mock.On("DeleteCluster", ctx, server)}
}

func (_c *ArgoDB_DeleteCluster_Call) Run(run func(ctx context.Context, server string)) *ArgoDB_DeleteCluster_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *ArgoDB_DeleteCluster_Call) Return(err error) *ArgoDB_DeleteCluster_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *ArgoDB_DeleteCluster_Call) RunAndReturn(run func(ctx context.Context, server string) error) *ArgoDB_DeleteCluster_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteGPGPublicKey provides a mock function for the type ArgoDB
func (_mock *ArgoDB) DeleteGPGPublicKey(ctx context.Context, keyID string) error {
	ret := _mock.Called(ctx, keyID)

	if len(ret) == 0 {
		panic("no return value specified for DeleteGPGPublicKey")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = returnFunc(ctx, keyID)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// ArgoDB_DeleteGPGPublicKey_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteGPGPublicKey'
type ArgoDB_DeleteGPGPublicKey_Call struct {
	*mock.Call
}

// DeleteGPGPublicKey is a helper method to define mock.On call
//   - ctx context.Context
//   - keyID string
func (_e *ArgoDB_Expecter) DeleteGPGPublicKey(ctx interface{}, keyID interface{}) *ArgoDB_DeleteGPGPublicKey_Call {
	return &ArgoDB_DeleteGPGPublicKey_Call{Call: _e.mock.On("DeleteGPGPublicKey", ctx, keyID)}
}

func (_c *ArgoDB_DeleteGPGPublicKey_Call) Run(run func(ctx context.Context, keyID string)) *ArgoDB_DeleteGPGPublicKey_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *ArgoDB_DeleteGPGPublicKey_Call) Return(err error) *ArgoDB_DeleteGPGPublicKey_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *ArgoDB_DeleteGPGPublicKey_Call) RunAndReturn(run func(ctx context.Context, keyID string) error) *ArgoDB_DeleteGPGPublicKey_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteRepository provides a mock function for the type ArgoDB
func (_mock *ArgoDB) DeleteRepository(ctx context.Context, name string, project string) error {
	ret := _mock.Called(ctx, name, project)

	if len(ret) == 0 {
		panic("no return value specified for DeleteRepository")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = returnFunc(ctx, name, project)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// ArgoDB_DeleteRepository_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteRepository'
type ArgoDB_DeleteRepository_Call struct {
	*mock.Call
}

// DeleteRepository is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
//   - project string
func (_e *ArgoDB_Expecter) DeleteRepository(ctx interface{}, name interface{}, project interface{}) *ArgoDB_DeleteRepository_Call {
	return &ArgoDB_DeleteRepository_Call{Call: _e.mock.On("DeleteRepository", ctx, name, project)}
}

func (_c *ArgoDB_DeleteRepository_Call) Run(run func(ctx context.Context, name string, project string)) *ArgoDB_DeleteRepository_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *ArgoDB_DeleteRepository_Call) Return(err error) *ArgoDB_DeleteRepository_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *ArgoDB_DeleteRepository_Call) RunAndReturn(run func(ctx context.Context, name string, project string) error) *ArgoDB_DeleteRepository_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteRepositoryCredentials provides a mock function for the type ArgoDB
func (_mock *ArgoDB) DeleteRepositoryCredentials(ctx context.Context, name string) error {
	ret := _mock.Called(ctx, name)

	if len(ret) == 0 {
		panic("no return value specified for DeleteRepositoryCredentials")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = returnFunc(ctx, name)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// ArgoDB_DeleteRepositoryCredentials_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteRepositoryCredentials'
type ArgoDB_DeleteRepositoryCredentials_Call struct {
	*mock.Call
}

// DeleteRepositoryCredentials is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
func (_e *ArgoDB_Expecter) DeleteRepositoryCredentials(ctx interface{}, name interface{}) *ArgoDB_DeleteRepositoryCredentials_Call {
	return &ArgoDB_DeleteRepositoryCredentials_Call{Call: _e.mock.On("DeleteRepositoryCredentials", ctx, name)}
}

func (_c *ArgoDB_DeleteRepositoryCredentials_Call) Run(run func(ctx context.Context, name string)) *ArgoDB_DeleteRepositoryCredentials_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *ArgoDB_DeleteRepositoryCredentials_Call) Return(err error) *ArgoDB_DeleteRepositoryCredentials_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *ArgoDB_DeleteRepositoryCredentials_Call) RunAndReturn(run func(ctx context.Context, name string) error) *ArgoDB_DeleteRepositoryCredentials_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteWriteRepository provides a mock function for the type ArgoDB
func (_mock *ArgoDB) DeleteWriteRepository(ctx context.Context, name string, project string) error {
	ret := _mock.Called(ctx, name, project)

	if len(ret) == 0 {
		panic("no return value specified for DeleteWriteRepository")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = returnFunc(ctx, name, project)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// ArgoDB_DeleteWriteRepository_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteWriteRepository'
type ArgoDB_DeleteWriteRepository_Call struct {
	*mock.Call
}

// DeleteWriteRepository is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
//   - project string
func (_e *ArgoDB_Expecter) DeleteWriteRepository(ctx interface{}, name interface{}, project interface{}) *ArgoDB_DeleteWriteRepository_Call {
	return &ArgoDB_DeleteWriteRepository_Call{Call: _e.mock.On("DeleteWriteRepository", ctx, name, project)}
}

func (_c *ArgoDB_DeleteWriteRepository_Call) Run(run func(ctx context.Context, name string, project string)) *ArgoDB_DeleteWriteRepository_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *ArgoDB_DeleteWriteRepository_Call) Return(err error) *ArgoDB_DeleteWriteRepository_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *ArgoDB_DeleteWriteRepository_Call) RunAndReturn(run func(ctx context.Context, name string, project string) error) *ArgoDB_DeleteWriteRepository_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteWriteRepositoryCredentials provides a mock function for the type ArgoDB
func (_mock *ArgoDB) DeleteWriteRepositoryCredentials(ctx context.Context, name string) error {
	ret := _mock.Called(ctx, name)

	if len(ret) == 0 {
		panic("no return value specified for DeleteWriteRepositoryCredentials")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = returnFunc(ctx, name)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// ArgoDB_DeleteWriteRepositoryCredentials_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteWriteRepositoryCredentials'
type ArgoDB_DeleteWriteRepositoryCredentials_Call struct {
	*mock.Call
}

// DeleteWriteRepositoryCredentials is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
func (_e *ArgoDB_Expecter) DeleteWriteRepositoryCredentials(ctx interface{}, name interface{}) *ArgoDB_DeleteWriteRepositoryCredentials_Call {
	return &ArgoDB_DeleteWriteRepositoryCredentials_Call{Call: _e.mock.On("DeleteWriteRepositoryCredentials", ctx, name)}
}

func (_c *ArgoDB_DeleteWriteRepositoryCredentials_Call) Run(run func(ctx context.Context, name string)) *ArgoDB_DeleteWriteRepositoryCredentials_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *ArgoDB_DeleteWriteRepositoryCredentials_Call) Return(err error) *ArgoDB_DeleteWriteRepositoryCredentials_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *ArgoDB_DeleteWriteRepositoryCredentials_Call) RunAndReturn(run func(ctx context.Context, name string) error) *ArgoDB_DeleteWriteRepositoryCredentials_Call {
	_c.Call.Return(run)
	return _c
}

// GetAllHelmRepositoryCredentials provides a mock function for the type ArgoDB
func (_mock *ArgoDB) GetAllHelmRepositoryCredentials(ctx context.Context) ([]*v1alpha1.RepoCreds, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetAllHelmRepositoryCredentials")
	}

	var r0 []*v1alpha1.RepoCreds
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) ([]*v1alpha1.RepoCreds, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) []*v1alpha1.RepoCreds); ok {
		r0 = returnFunc(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*v1alpha1.RepoCreds)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ArgoDB_GetAllHelmRepositoryCredentials_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAllHelmRepositoryCredentials'
type ArgoDB_GetAllHelmRepositoryCredentials_Call struct {
	*mock.Call
}

// GetAllHelmRepositoryCredentials is a helper method to define mock.On call
//   - ctx context.Context
func (_e *ArgoDB_Expecter) GetAllHelmRepositoryCredentials(ctx interface{}) *ArgoDB_GetAllHelmRepositoryCredentials_Call {
	return &ArgoDB_GetAllHelmRepositoryCredentials_Call{Call: _e.mock.On("GetAllHelmRepositoryCredentials", ctx)}
}

func (_c *ArgoDB_GetAllHelmRepositoryCredentials_Call) Run(run func(ctx context.Context)) *ArgoDB_GetAllHelmRepositoryCredentials_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *ArgoDB_GetAllHelmRepositoryCredentials_Call) Return(repoCredss []*v1alpha1.RepoCreds, err error) *ArgoDB_GetAllHelmRepositoryCredentials_Call {
	_c.Call.Return(repoCredss, err)
	return _c
}

func (_c *ArgoDB_GetAllHelmRepositoryCredentials_Call) RunAndReturn(run func(ctx context.Context) ([]*v1alpha1.RepoCreds, error)) *ArgoDB_GetAllHelmRepositoryCredentials_Call {
	_c.Call.Return(run)
	return _c
}

// GetAllOCIRepositoryCredentials provides a mock function for the type ArgoDB
func (_mock *ArgoDB) GetAllOCIRepositoryCredentials(ctx context.Context) ([]*v1alpha1.RepoCreds, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetAllOCIRepositoryCredentials")
	}

	var r0 []*v1alpha1.RepoCreds
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) ([]*v1alpha1.RepoCreds, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) []*v1alpha1.RepoCreds); ok {
		r0 = returnFunc(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*v1alpha1.RepoCreds)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ArgoDB_GetAllOCIRepositoryCredentials_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAllOCIRepositoryCredentials'
type ArgoDB_GetAllOCIRepositoryCredentials_Call struct {
	*mock.Call
}

// GetAllOCIRepositoryCredentials is a helper method to define mock.On call
//   - ctx context.Context
func (_e *ArgoDB_Expecter) GetAllOCIRepositoryCredentials(ctx interface{}) *ArgoDB_GetAllOCIRepositoryCredentials_Call {
	return &ArgoDB_GetAllOCIRepositoryCredentials_Call{Call: _e.mock.On("GetAllOCIRepositoryCredentials", ctx)}
}

func (_c *ArgoDB_GetAllOCIRepositoryCredentials_Call) Run(run func(ctx context.Context)) *ArgoDB_GetAllOCIRepositoryCredentials_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *ArgoDB_GetAllOCIRepositoryCredentials_Call) Return(repoCredss []*v1alpha1.RepoCreds, err error) *ArgoDB_GetAllOCIRepositoryCredentials_Call {
	_c.Call.Return(repoCredss, err)
	return _c
}

func (_c *ArgoDB_GetAllOCIRepositoryCredentials_Call) RunAndReturn(run func(ctx context.Context) ([]*v1alpha1.RepoCreds, error)) *ArgoDB_GetAllOCIRepositoryCredentials_Call {
	_c.Call.Return(run)
	return _c
}

// GetApplicationControllerReplicas provides a mock function for the type ArgoDB
func (_mock *ArgoDB) GetApplicationControllerReplicas() int {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetApplicationControllerReplicas")
	}

	var r0 int
	if returnFunc, ok := ret.Get(0).(func() int); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(int)
	}
	return r0
}

// ArgoDB_GetApplicationControllerReplicas_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetApplicationControllerReplicas'
type ArgoDB_GetApplicationControllerReplicas_Call struct {
	*mock.Call
}

// GetApplicationControllerReplicas is a helper method to define mock.On call
func (_e *ArgoDB_Expecter) GetApplicationControllerReplicas() *ArgoDB_GetApplicationControllerReplicas_Call {
	return &ArgoDB_GetApplicationControllerReplicas_Call{Call: _e.mock.On("GetApplicationControllerReplicas")}
}

func (_c *ArgoDB_GetApplicationControllerReplicas_Call) Run(run func()) *ArgoDB_GetApplicationControllerReplicas_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *ArgoDB_GetApplicationControllerReplicas_Call) Return(n int) *ArgoDB_GetApplicationControllerReplicas_Call {
	_c.Call.Return(n)
	return _c
}

func (_c *ArgoDB_GetApplicationControllerReplicas_Call) RunAndReturn(run func() int) *ArgoDB_GetApplicationControllerReplicas_Call {
	_c.Call.Return(run)
	return _c
}

// GetCluster provides a mock function for the type ArgoDB
func (_mock *ArgoDB) GetCluster(ctx context.Context, server string) (*v1alpha1.Cluster, error) {
	ret := _mock.Called(ctx, server)

	if len(ret) == 0 {
		panic("no return value specified for GetCluster")
	}

	var r0 *v1alpha1.Cluster
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (*v1alpha1.Cluster, error)); ok {
		return returnFunc(ctx, server)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) *v1alpha1.Cluster); ok {
		r0 = returnFunc(ctx, server)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*v1alpha1.Cluster)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, server)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ArgoDB_GetCluster_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetCluster'
type ArgoDB_GetCluster_Call struct {
	*mock.Call
}

// GetCluster is a helper method to define mock.On call
//   - ctx context.Context
//   - server string
func (_e *ArgoDB_Expecter) GetCluster(ctx interface{}, server interface{}) *ArgoDB_GetCluster_Call {
	return &ArgoDB_GetCluster_Call{Call: _e.mock.On("GetCluster", ctx, server)}
}

func (_c *ArgoDB_GetCluster_Call) Run(run func(ctx context.Context, server string)) *ArgoDB_GetCluster_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *ArgoDB_GetCluster_Call) Return(cluster *v1alpha1.Cluster, err error) *ArgoDB_GetCluster_Call {
	_c.Call.Return(cluster, err)
	return _c
}

func (_c *ArgoDB_GetCluster_Call) RunAndReturn(run func(ctx context.Context, server string) (*v1alpha1.Cluster, error)) *ArgoDB_GetCluster_Call {
	_c.Call.Return(run)
	return _c
}

// GetClusterServersByName provides a mock function for the type ArgoDB
func (_mock *ArgoDB) GetClusterServersByName(ctx context.Context, name string) ([]string, error) {
	ret := _mock.Called(ctx, name)

	if len(ret) == 0 {
		panic("no return value specified for GetClusterServersByName")
	}

	var r0 []string
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) ([]string, error)); ok {
		return returnFunc(ctx, name)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) []string); ok {
		r0 = returnFunc(ctx, name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, name)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ArgoDB_GetClusterServersByName_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetClusterServersByName'
type ArgoDB_GetClusterServersByName_Call struct {
	*mock.Call
}

// GetClusterServersByName is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
func (_e *ArgoDB_Expecter) GetClusterServersByName(ctx interface{}, name interface{}) *ArgoDB_GetClusterServersByName_Call {
	return &ArgoDB_GetClusterServersByName_Call{Call: _e.mock.On("GetClusterServersByName", ctx, name)}
}

func (_c *ArgoDB_GetClusterServersByName_Call) Run(run func(ctx context.Context, name string)) *ArgoDB_GetClusterServersByName_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *ArgoDB_GetClusterServersByName_Call) Return(strings []string, err error) *ArgoDB_GetClusterServersByName_Call {
	_c.Call.Return(strings, err)
	return _c
}

func (_c *ArgoDB_GetClusterServersByName_Call) RunAndReturn(run func(ctx context.Context, name string) ([]string, error)) *ArgoDB_GetClusterServersByName_Call {
	_c.Call.Return(run)
	return _c
}

// GetProjectClusters provides a mock function for the type ArgoDB
func (_mock *ArgoDB) GetProjectClusters(ctx context.Context, project string) ([]*v1alpha1.Cluster, error) {
	ret := _mock.Called(ctx, project)

	if len(ret) == 0 {
		panic("no return value specified for GetProjectClusters")
	}

	var r0 []*v1alpha1.Cluster
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) ([]*v1alpha1.Cluster, error)); ok {
		return returnFunc(ctx, project)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) []*v1alpha1.Cluster); ok {
		r0 = returnFunc(ctx, project)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*v1alpha1.Cluster)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, project)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ArgoDB_GetProjectClusters_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetProjectClusters'
type ArgoDB_GetProjectClusters_Call struct {
	*mock.Call
}

// GetProjectClusters is a helper method to define mock.On call
//   - ctx context.Context
//   - project string
func (_e *ArgoDB_Expecter) GetProjectClusters(ctx interface{}, project interface{}) *ArgoDB_GetProjectClusters_Call {
	return &ArgoDB_GetProjectClusters_Call{Call: _e.mock.On("GetProjectClusters", ctx, project)}
}

func (_c *ArgoDB_GetProjectClusters_Call) Run(run func(ctx context.Context, project string)) *ArgoDB_GetProjectClusters_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *ArgoDB_GetProjectClusters_Call) Return(clusters []*v1alpha1.Cluster, err error) *ArgoDB_GetProjectClusters_Call {
	_c.Call.Return(clusters, err)
	return _c
}

func (_c *ArgoDB_GetProjectClusters_Call) RunAndReturn(run func(ctx context.Context, project string) ([]*v1alpha1.Cluster, error)) *ArgoDB_GetProjectClusters_Call {
	_c.Call.Return(run)
	return _c
}

// GetProjectRepositories provides a mock function for the type ArgoDB
func (_mock *ArgoDB) GetProjectRepositories(project string) ([]*v1alpha1.Repository, error) {
	ret := _mock.Called(project)

	if len(ret) == 0 {
		panic("no return value specified for GetProjectRepositories")
	}

	var r0 []*v1alpha1.Repository
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(string) ([]*v1alpha1.Repository, error)); ok {
		return returnFunc(project)
	}
	if returnFunc, ok := ret.Get(0).(func(string) []*v1alpha1.Repository); ok {
		r0 = returnFunc(project)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*v1alpha1.Repository)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(string) error); ok {
		r1 = returnFunc(project)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ArgoDB_GetProjectRepositories_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetProjectRepositories'
type ArgoDB_GetProjectRepositories_Call struct {
	*mock.Call
}

// GetProjectRepositories is a helper method to define mock.On call
//   - project string
func (_e *ArgoDB_Expecter) GetProjectRepositories(project interface{}) *ArgoDB_GetProjectRepositories_Call {
	return &ArgoDB_GetProjectRepositories_Call{Call: _e.mock.On("GetProjectRepositories", project)}
}

func (_c *ArgoDB_GetProjectRepositories_Call) Run(run func(project string)) *ArgoDB_GetProjectRepositories_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *ArgoDB_GetProjectRepositories_Call) Return(repositorys []*v1alpha1.Repository, err error) *ArgoDB_GetProjectRepositories_Call {
	_c.Call.Return(repositorys, err)
	return _c
}

func (_c *ArgoDB_GetProjectRepositories_Call) RunAndReturn(run func(project string) ([]*v1alpha1.Repository, error)) *ArgoDB_GetProjectRepositories_Call {
	_c.Call.Return(run)
	return _c
}

// GetProjectWriteRepositories provides a mock function for the type ArgoDB
func (_mock *ArgoDB) GetProjectWriteRepositories(project string) ([]*v1alpha1.Repository, error) {
	ret := _mock.Called(project)

	if len(ret) == 0 {
		panic("no return value specified for GetProjectWriteRepositories")
	}

	var r0 []*v1alpha1.Repository
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(string) ([]*v1alpha1.Repository, error)); ok {
		return returnFunc(project)
	}
	if returnFunc, ok := ret.Get(0).(func(string) []*v1alpha1.Repository); ok {
		r0 = returnFunc(project)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*v1alpha1.Repository)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(string) error); ok {
		r1 = returnFunc(project)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ArgoDB_GetProjectWriteRepositories_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetProjectWriteRepositories'
type ArgoDB_GetProjectWriteRepositories_Call struct {
	*mock.Call
}

// GetProjectWriteRepositories is a helper method to define mock.On call
//   - project string
func (_e *ArgoDB_Expecter) GetProjectWriteRepositories(project interface{}) *ArgoDB_GetProjectWriteRepositories_Call {
	return &ArgoDB_GetProjectWriteRepositories_Call{Call: _e.mock.On("GetProjectWriteRepositories", project)}
}

func (_c *ArgoDB_GetProjectWriteRepositories_Call) Run(run func(project string)) *ArgoDB_GetProjectWriteRepositories_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *ArgoDB_GetProjectWriteRepositories_Call) Return(repositorys []*v1alpha1.Repository, err error) *ArgoDB_GetProjectWriteRepositories_Call {
	_c.Call.Return(repositorys, err)
	return _c
}

func (_c *ArgoDB_GetProjectWriteRepositories_Call) RunAndReturn(run func(project string) ([]*v1alpha1.Repository, error)) *ArgoDB_GetProjectWriteRepositories_Call {
	_c.Call.Return(run)
	return _c
}

// GetRepository provides a mock function for the type ArgoDB
func (_mock *ArgoDB) GetRepository(ctx context.Context, url string, project string) (*v1alpha1.Repository, error) {
	ret := _mock.Called(ctx, url, project)

	if len(ret) == 0 {
		panic("no return value specified for GetRepository")
	}

	var r0 *v1alpha1.Repository
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string) (*v1alpha1.Repository, error)); ok {
		return returnFunc(ctx, url, project)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string) *v1alpha1.Repository); ok {
		r0 = returnFunc(ctx, url, project)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*v1alpha1.Repository)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = returnFunc(ctx, url, project)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ArgoDB_GetRepository_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetRepository'
type ArgoDB_GetRepository_Call struct {
	*mock.Call
}

// GetRepository is a helper method to define mock.On call
//   - ctx context.Context
//   - url string
//   - project string
func (_e *ArgoDB_Expecter) GetRepository(ctx interface{}, url interface{}, project interface{}) *ArgoDB_GetRepository_Call {
	return &ArgoDB_GetRepository_Call{Call: _e.mock.On("GetRepository", ctx, url, project)}
}

func (_c *ArgoDB_GetRepository_Call) Run(run func(ctx context.Context, url string, project string)) *ArgoDB_GetRepository_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *ArgoDB_GetRepository_Call) Return(repository *v1alpha1.Repository, err error) *ArgoDB_GetRepository_Call {
	_c.Call.Return(repository, err)
	return _c
}

func (_c *ArgoDB_GetRepository_Call) RunAndReturn(run func(ctx context.Context, url string, project string) (*v1alpha1.Repository, error)) *ArgoDB_GetRepository_Call {
	_c.Call.Return(run)
	return _c
}

// GetRepositoryCredentials provides a mock function for the type ArgoDB
func (_mock *ArgoDB) GetRepositoryCredentials(ctx context.Context, name string) (*v1alpha1.RepoCreds, error) {
	ret := _mock.Called(ctx, name)

	if len(ret) == 0 {
		panic("no return value specified for GetRepositoryCredentials")
	}

	var r0 *v1alpha1.RepoCreds
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (*v1alpha1.RepoCreds, error)); ok {
		return returnFunc(ctx, name)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) *v1alpha1.RepoCreds); ok {
		r0 = returnFunc(ctx, name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*v1alpha1.RepoCreds)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, name)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ArgoDB_GetRepositoryCredentials_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetRepositoryCredentials'
type ArgoDB_GetRepositoryCredentials_Call struct {
	*mock.Call
}

// GetRepositoryCredentials is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
func (_e *ArgoDB_Expecter) GetRepositoryCredentials(ctx interface{}, name interface{}) *ArgoDB_GetRepositoryCredentials_Call {
	return &ArgoDB_GetRepositoryCredentials_Call{Call: _e.mock.On("GetRepositoryCredentials", ctx, name)}
}

func (_c *ArgoDB_GetRepositoryCredentials_Call) Run(run func(ctx context.Context, name string)) *ArgoDB_GetRepositoryCredentials_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *ArgoDB_GetRepositoryCredentials_Call) Return(repoCreds *v1alpha1.RepoCreds, err error) *ArgoDB_GetRepositoryCredentials_Call {
	_c.Call.Return(repoCreds, err)
	return _c
}

func (_c *ArgoDB_GetRepositoryCredentials_Call) RunAndReturn(run func(ctx context.Context, name string) (*v1alpha1.RepoCreds, error)) *ArgoDB_GetRepositoryCredentials_Call {
	_c.Call.Return(run)
	return _c
}

// GetWriteRepository provides a mock function for the type ArgoDB
func (_mock *ArgoDB) GetWriteRepository(ctx context.Context, url string, project string) (*v1alpha1.Repository, error) {
	ret := _mock.Called(ctx, url, project)

	if len(ret) == 0 {
		panic("no return value specified for GetWriteRepository")
	}

	var r0 *v1alpha1.Repository
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string) (*v1alpha1.Repository, error)); ok {
		return returnFunc(ctx, url, project)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string) *v1alpha1.Repository); ok {
		r0 = returnFunc(ctx, url, project)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*v1alpha1.Repository)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = returnFunc(ctx, url, project)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ArgoDB_GetWriteRepository_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetWriteRepository'
type ArgoDB_GetWriteRepository_Call struct {
	*mock.Call
}

// GetWriteRepository is a helper method to define mock.On call
//   - ctx context.Context
//   - url string
//   - project string
func (_e *ArgoDB_Expecter) GetWriteRepository(ctx interface{}, url interface{}, project interface{}) *ArgoDB_GetWriteRepository_Call {
	return &ArgoDB_GetWriteRepository_Call{Call: _e.mock.On("GetWriteRepository", ctx, url, project)}
}

func (_c *ArgoDB_GetWriteRepository_Call) Run(run func(ctx context.Context, url string, project string)) *ArgoDB_GetWriteRepository_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *ArgoDB_GetWriteRepository_Call) Return(repository *v1alpha1.Repository, err error) *ArgoDB_GetWriteRepository_Call {
	_c.Call.Return(repository, err)
	return _c
}

func (_c *ArgoDB_GetWriteRepository_Call) RunAndReturn(run func(ctx context.Context, url string, project string) (*v1alpha1.Repository, error)) *ArgoDB_GetWriteRepository_Call {
	_c.Call.Return(run)
	return _c
}

// GetWriteRepositoryCredentials provides a mock function for the type ArgoDB
func (_mock *ArgoDB) GetWriteRepositoryCredentials(ctx context.Context, name string) (*v1alpha1.RepoCreds, error) {
	ret := _mock.Called(ctx, name)

	if len(ret) == 0 {
		panic("no return value specified for GetWriteRepositoryCredentials")
	}

	var r0 *v1alpha1.RepoCreds
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (*v1alpha1.RepoCreds, error)); ok {
		return returnFunc(ctx, name)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) *v1alpha1.RepoCreds); ok {
		r0 = returnFunc(ctx, name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*v1alpha1.RepoCreds)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, name)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ArgoDB_GetWriteRepositoryCredentials_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetWriteRepositoryCredentials'
type ArgoDB_GetWriteRepositoryCredentials_Call struct {
	*mock.Call
}

// GetWriteRepositoryCredentials is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
func (_e *ArgoDB_Expecter) GetWriteRepositoryCredentials(ctx interface{}, name interface{}) *ArgoDB_GetWriteRepositoryCredentials_Call {
	return &ArgoDB_GetWriteRepositoryCredentials_Call{Call: _e.mock.On("GetWriteRepositoryCredentials", ctx, name)}
}

func (_c *ArgoDB_GetWriteRepositoryCredentials_Call) Run(run func(ctx context.Context, name string)) *ArgoDB_GetWriteRepositoryCredentials_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *ArgoDB_GetWriteRepositoryCredentials_Call) Return(repoCreds *v1alpha1.RepoCreds, err error) *ArgoDB_GetWriteRepositoryCredentials_Call {
	_c.Call.Return(repoCreds, err)
	return _c
}

func (_c *ArgoDB_GetWriteRepositoryCredentials_Call) RunAndReturn(run func(ctx context.Context, name string) (*v1alpha1.RepoCreds, error)) *ArgoDB_GetWriteRepositoryCredentials_Call {
	_c.Call.Return(run)
	return _c
}

// ListClusters provides a mock function for the type ArgoDB
func (_mock *ArgoDB) ListClusters(ctx context.Context) (*v1alpha1.ClusterList, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ListClusters")
	}

	var r0 *v1alpha1.ClusterList
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (*v1alpha1.ClusterList, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) *v1alpha1.ClusterList); ok {
		r0 = returnFunc(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*v1alpha1.ClusterList)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ArgoDB_ListClusters_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListClusters'
type ArgoDB_ListClusters_Call struct {
	*mock.Call
}

// ListClusters is a helper method to define mock.On call
//   - ctx context.Context
func (_e *ArgoDB_Expecter) ListClusters(ctx interface{}) *ArgoDB_ListClusters_Call {
	return &ArgoDB_ListClusters_Call{Call: _e.mock.On("ListClusters", ctx)}
}

func (_c *ArgoDB_ListClusters_Call) Run(run func(ctx context.Context)) *ArgoDB_ListClusters_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *ArgoDB_ListClusters_Call) Return(clusterList *v1alpha1.ClusterList, err error) *ArgoDB_ListClusters_Call {
	_c.Call.Return(clusterList, err)
	return _c
}

func (_c *ArgoDB_ListClusters_Call) RunAndReturn(run func(ctx context.Context) (*v1alpha1.ClusterList, error)) *ArgoDB_ListClusters_Call {
	_c.Call.Return(run)
	return _c
}

// ListConfiguredGPGPublicKeys provides a mock function for the type ArgoDB
func (_mock *ArgoDB) ListConfiguredGPGPublicKeys(ctx context.Context) (map[string]*v1alpha1.GnuPGPublicKey, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ListConfiguredGPGPublicKeys")
	}

	var r0 map[string]*v1alpha1.GnuPGPublicKey
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (map[string]*v1alpha1.GnuPGPublicKey, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) map[string]*v1alpha1.GnuPGPublicKey); ok {
		r0 = returnFunc(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]*v1alpha1.GnuPGPublicKey)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ArgoDB_ListConfiguredGPGPublicKeys_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListConfiguredGPGPublicKeys'
type ArgoDB_ListConfiguredGPGPublicKeys_Call struct {
	*mock.Call
}

// ListConfiguredGPGPublicKeys is a helper method to define mock.On call
//   - ctx context.Context
func (_e *ArgoDB_Expecter) ListConfiguredGPGPublicKeys(ctx interface{}) *ArgoDB_ListConfiguredGPGPublicKeys_Call {
	return &ArgoDB_ListConfiguredGPGPublicKeys_Call{Call: _e.mock.On("ListConfiguredGPGPublicKeys", ctx)}
}

func (_c *ArgoDB_ListConfiguredGPGPublicKeys_Call) Run(run func(ctx context.Context)) *ArgoDB_ListConfiguredGPGPublicKeys_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *ArgoDB_ListConfiguredGPGPublicKeys_Call) Return(stringToGnuPGPublicKey map[string]*v1alpha1.GnuPGPublicKey, err error) *ArgoDB_ListConfiguredGPGPublicKeys_Call {
	_c.Call.Return(stringToGnuPGPublicKey, err)
	return _c
}

func (_c *ArgoDB_ListConfiguredGPGPublicKeys_Call) RunAndReturn(run func(ctx context.Context) (map[string]*v1alpha1.GnuPGPublicKey, error)) *ArgoDB_ListConfiguredGPGPublicKeys_Call {
	_c.Call.Return(run)
	return _c
}

// ListHelmRepositories provides a mock function for the type ArgoDB
func (_mock *ArgoDB) ListHelmRepositories(ctx context.Context) ([]*v1alpha1.Repository, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ListHelmRepositories")
	}

	var r0 []*v1alpha1.Repository
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) ([]*v1alpha1.Repository, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) []*v1alpha1.Repository); ok {
		r0 = returnFunc(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*v1alpha1.Repository)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ArgoDB_ListHelmRepositories_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListHelmRepositories'
type ArgoDB_ListHelmRepositories_Call struct {
	*mock.Call
}

// ListHelmRepositories is a helper method to define mock.On call
//   - ctx context.Context
func (_e *ArgoDB_Expecter) ListHelmRepositories(ctx interface{}) *ArgoDB_ListHelmRepositories_Call {
	return &ArgoDB_ListHelmRepositories_Call{Call: _e.mock.On("ListHelmRepositories", ctx)}
}

func (_c *ArgoDB_ListHelmRepositories_Call) Run(run func(ctx context.Context)) *ArgoDB_ListHelmRepositories_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *ArgoDB_ListHelmRepositories_Call) Return(repositorys []*v1alpha1.Repository, err error) *ArgoDB_ListHelmRepositories_Call {
	_c.Call.Return(repositorys, err)
	return _c
}

func (_c *ArgoDB_ListHelmRepositories_Call) RunAndReturn(run func(ctx context.Context) ([]*v1alpha1.Repository, error)) *ArgoDB_ListHelmRepositories_Call {
	_c.Call.Return(run)
	return _c
}

// ListOCIRepositories provides a mock function for the type ArgoDB
func (_mock *ArgoDB) ListOCIRepositories(ctx context.Context) ([]*v1alpha1.Repository, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ListOCIRepositories")
	}

	var r0 []*v1alpha1.Repository
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) ([]*v1alpha1.Repository, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) []*v1alpha1.Repository); ok {
		r0 = returnFunc(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*v1alpha1.Repository)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ArgoDB_ListOCIRepositories_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListOCIRepositories'
type ArgoDB_ListOCIRepositories_Call struct {
	*mock.Call
}

// ListOCIRepositories is a helper method to define mock.On call
//   - ctx context.Context
func (_e *ArgoDB_Expecter) ListOCIRepositories(ctx interface{}) *ArgoDB_ListOCIRepositories_Call {
	return &ArgoDB_ListOCIRepositories_Call{Call: _e.mock.On("ListOCIRepositories", ctx)}
}

func (_c *ArgoDB_ListOCIRepositories_Call) Run(run func(ctx context.Context)) *ArgoDB_ListOCIRepositories_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *ArgoDB_ListOCIRepositories_Call) Return(repositorys []*v1alpha1.Repository, err error) *ArgoDB_ListOCIRepositories_Call {
	_c.Call.Return(repositorys, err)
	return _c
}

func (_c *ArgoDB_ListOCIRepositories_Call) RunAndReturn(run func(ctx context.Context) ([]*v1alpha1.Repository, error)) *ArgoDB_ListOCIRepositories_Call {
	_c.Call.Return(run)
	return _c
}

// ListRepoCertificates provides a mock function for the type ArgoDB
func (_mock *ArgoDB) ListRepoCertificates(ctx context.Context, selector *db.CertificateListSelector) (*v1alpha1.RepositoryCertificateList, error) {
	ret := _mock.Called(ctx, selector)

	if len(ret) == 0 {
		panic("no return value specified for ListRepoCertificates")
	}

	var r0 *v1alpha1.RepositoryCertificateList
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *db.CertificateListSelector) (*v1alpha1.RepositoryCertificateList, error)); ok {
		return returnFunc(ctx, selector)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *db.CertificateListSelector) *v1alpha1.RepositoryCertificateList); ok {
		r0 = returnFunc(ctx, selector)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*v1alpha1.RepositoryCertificateList)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *db.CertificateListSelector) error); ok {
		r1 = returnFunc(ctx, selector)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ArgoDB_ListRepoCertificates_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListRepoCertificates'
type ArgoDB_ListRepoCertificates_Call struct {
	*mock.Call
}

// ListRepoCertificates is a helper method to define mock.On call
//   - ctx context.Context
//   - selector *db.CertificateListSelector
func (_e *ArgoDB_Expecter) ListRepoCertificates(ctx interface{}, selector interface{}) *ArgoDB_ListRepoCertificates_Call {
	return &ArgoDB_ListRepoCertificates_Call{Call: _e.mock.On("ListRepoCertificates", ctx, selector)}
}

func (_c *ArgoDB_ListRepoCertificates_Call) Run(run func(ctx context.Context, selector *db.CertificateListSelector)) *ArgoDB_ListRepoCertificates_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *db.CertificateListSelector
		if args[1] != nil {
			arg1 = args[1].(*db.CertificateListSelector)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *ArgoDB_ListRepoCertificates_Call) Return(repositoryCertificateList *v1alpha1.RepositoryCertificateList, err error) *ArgoDB_ListRepoCertificates_Call {
	_c.Call.Return(repositoryCertificateList, err)
	return _c
}

func (_c *ArgoDB_ListRepoCertificates_Call) RunAndReturn(run func(ctx context.Context, selector *db.CertificateListSelector) (*v1alpha1.RepositoryCertificateList, error)) *ArgoDB_ListRepoCertificates_Call {
	_c.Call.Return(run)
	return _c
}

// ListRepositories provides a mock function for the type ArgoDB
func (_mock *ArgoDB) ListRepositories(ctx context.Context) ([]*v1alpha1.Repository, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ListRepositories")
	}

	var r0 []*v1alpha1.Repository
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) ([]*v1alpha1.Repository, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) []*v1alpha1.Repository); ok {
		r0 = returnFunc(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*v1alpha1.Repository)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ArgoDB_ListRepositories_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListRepositories'
type ArgoDB_ListRepositories_Call struct {
	*mock.Call
}

// ListRepositories is a helper method to define mock.On call
//   - ctx context.Context
func (_e *ArgoDB_Expecter) ListRepositories(ctx interface{}) *ArgoDB_ListRepositories_Call {
	return &ArgoDB_ListRepositories_Call{Call: _e.mock.On("ListRepositories", ctx)}
}

func (_c *ArgoDB_ListRepositories_Call) Run(run func(ctx context.Context)) *ArgoDB_ListRepositories_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *ArgoDB_ListRepositories_Call) Return(repositorys []*v1alpha1.Repository, err error) *ArgoDB_ListRepositories_Call {
	_c.Call.Return(repositorys, err)
	return _c
}

func (_c *ArgoDB_ListRepositories_Call) RunAndReturn(run func(ctx context.Context) ([]*v1alpha1.Repository, error)) *ArgoDB_ListRepositories_Call {
	_c.Call.Return(run)
	return _c
}

// ListRepositoryCredentials provides a mock function for the type ArgoDB
func (_mock *ArgoDB) ListRepositoryCredentials(ctx context.Context) ([]string, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ListRepositoryCredentials")
	}

	var r0 []string
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) ([]string, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) []string); ok {
		r0 = returnFunc(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ArgoDB_ListRepositoryCredentials_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListRepositoryCredentials'
type ArgoDB_ListRepositoryCredentials_Call struct {
	*mock.Call
}

// ListRepositoryCredentials is a helper method to define mock.On call
//   - ctx context.Context
func (_e *ArgoDB_Expecter) ListRepositoryCredentials(ctx interface{}) *ArgoDB_ListRepositoryCredentials_Call {
	return &ArgoDB_ListRepositoryCredentials_Call{Call: _e.mock.On("ListRepositoryCredentials", ctx)}
}

func (_c *ArgoDB_ListRepositoryCredentials_Call) Run(run func(ctx context.Context)) *ArgoDB_ListRepositoryCredentials_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *ArgoDB_ListRepositoryCredentials_Call) Return(strings []string, err error) *ArgoDB_ListRepositoryCredentials_Call {
	_c.Call.Return(strings, err)
	return _c
}

func (_c *ArgoDB_ListRepositoryCredentials_Call) RunAndReturn(run func(ctx context.Context) ([]string, error)) *ArgoDB_ListRepositoryCredentials_Call {
	_c.Call.Return(run)
	return _c
}

// ListWriteRepositories provides a mock function for the type ArgoDB
func (_mock *ArgoDB) ListWriteRepositories(ctx context.Context) ([]*v1alpha1.Repository, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ListWriteRepositories")
	}

	var r0 []*v1alpha1.Repository
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) ([]*v1alpha1.Repository, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) []*v1alpha1.Repository); ok {
		r0 = returnFunc(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*v1alpha1.Repository)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ArgoDB_ListWriteRepositories_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListWriteRepositories'
type ArgoDB_ListWriteRepositories_Call struct {
	*mock.Call
}

// ListWriteRepositories is a helper method to define mock.On call
//   - ctx context.Context
func (_e *ArgoDB_Expecter) ListWriteRepositories(ctx interface{}) *ArgoDB_ListWriteRepositories_Call {
	return &ArgoDB_ListWriteRepositories_Call{Call: _e.mock.On("ListWriteRepositories", ctx)}
}

func (_c *ArgoDB_ListWriteRepositories_Call) Run(run func(ctx context.Context)) *ArgoDB_ListWriteRepositories_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *ArgoDB_ListWriteRepositories_Call) Return(repositorys []*v1alpha1.Repository, err error) *ArgoDB_ListWriteRepositories_Call {
	_c.Call.Return(repositorys, err)
	return _c
}

func (_c *ArgoDB_ListWriteRepositories_Call) RunAndReturn(run func(ctx context.Context) ([]*v1alpha1.Repository, error)) *ArgoDB_ListWriteRepositories_Call {
	_c.Call.Return(run)
	return _c
}

// ListWriteRepositoryCredentials provides a mock function for the type ArgoDB
func (_mock *ArgoDB) ListWriteRepositoryCredentials(ctx context.Context) ([]string, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ListWriteRepositoryCredentials")
	}

	var r0 []string
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) ([]string, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) []string); ok {
		r0 = returnFunc(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ArgoDB_ListWriteRepositoryCredentials_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListWriteRepositoryCredentials'
type ArgoDB_ListWriteRepositoryCredentials_Call struct {
	*mock.Call
}

// ListWriteRepositoryCredentials is a helper method to define mock.On call
//   - ctx context.Context
func (_e *ArgoDB_Expecter) ListWriteRepositoryCredentials(ctx interface{}) *ArgoDB_ListWriteRepositoryCredentials_Call {
	return &ArgoDB_ListWriteRepositoryCredentials_Call{Call: _e.mock.On("ListWriteRepositoryCredentials", ctx)}
}

func (_c *ArgoDB_ListWriteRepositoryCredentials_Call) Run(run func(ctx context.Context)) *ArgoDB_ListWriteRepositoryCredentials_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *ArgoDB_ListWriteRepositoryCredentials_Call) Return(strings []string, err error) *ArgoDB_ListWriteRepositoryCredentials_Call {
	_c.Call.Return(strings, err)
	return _c
}

func (_c *ArgoDB_ListWriteRepositoryCredentials_Call) RunAndReturn(run func(ctx context.Context) ([]string, error)) *ArgoDB_ListWriteRepositoryCredentials_Call {
	_c.Call.Return(run)
	return _c
}

// RemoveRepoCertificates provides a mock function for the type ArgoDB
func (_mock *ArgoDB) RemoveRepoCertificates(ctx context.Context, selector *db.CertificateListSelector) (*v1alpha1.RepositoryCertificateList, error) {
	ret := _mock.Called(ctx, selector)

	if len(ret) == 0 {
		panic("no return value specified for RemoveRepoCertificates")
	}

	var r0 *v1alpha1.RepositoryCertificateList
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *db.CertificateListSelector) (*v1alpha1.RepositoryCertificateList, error)); ok {
		return returnFunc(ctx, selector)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *db.CertificateListSelector) *v1alpha1.RepositoryCertificateList); ok {
		r0 = returnFunc(ctx, selector)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*v1alpha1.RepositoryCertificateList)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *db.CertificateListSelector) error); ok {
		r1 = returnFunc(ctx, selector)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ArgoDB_RemoveRepoCertificates_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoveRepoCertificates'
type ArgoDB_RemoveRepoCertificates_Call struct {
	*mock.Call
}

// RemoveRepoCertificates is a helper method to define mock.On call
//   - ctx context.Context
//   - selector *db.CertificateListSelector
func (_e *ArgoDB_Expecter) RemoveRepoCertificates(ctx interface{}, selector interface{}) *ArgoDB_RemoveRepoCertificates_Call {
	return &ArgoDB_RemoveRepoCertificates_Call{Call: _e.mock.On("RemoveRepoCertificates", ctx, selector)}
}

func (_c *ArgoDB_RemoveRepoCertificates_Call) Run(run func(ctx context.Context, selector *db.CertificateListSelector)) *ArgoDB_RemoveRepoCertificates_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *db.CertificateListSelector
		if args[1] != nil {
			arg1 = args[1].(*db.CertificateListSelector)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *ArgoDB_RemoveRepoCertificates_Call) Return(repositoryCertificateList *v1alpha1.RepositoryCertificateList, err error) *ArgoDB_RemoveRepoCertificates_Call {
	_c.Call.Return(repositoryCertificateList, err)
	return _c
}

func (_c *ArgoDB_RemoveRepoCertificates_Call) RunAndReturn(run func(ctx context.Context, selector *db.CertificateListSelector) (*v1alpha1.RepositoryCertificateList, error)) *ArgoDB_RemoveRepoCertificates_Call {
	_c.Call.Return(run)
	return _c
}

// RepositoryExists provides a mock function for the type ArgoDB
func (_mock *ArgoDB) RepositoryExists(ctx context.Context, repoURL string, project string) (bool, error) {
	ret := _mock.Called(ctx, repoURL, project)

	if len(ret) == 0 {
		panic("no return value specified for RepositoryExists")
	}

	var r0 bool
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string) (bool, error)); ok {
		return returnFunc(ctx, repoURL, project)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string) bool); ok {
		r0 = returnFunc(ctx, repoURL, project)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = returnFunc(ctx, repoURL, project)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ArgoDB_RepositoryExists_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RepositoryExists'
type ArgoDB_RepositoryExists_Call struct {
	*mock.Call
}

// RepositoryExists is a helper method to define mock.On call
//   - ctx context.Context
//   - repoURL string
//   - project string
func (_e *ArgoDB_Expecter) RepositoryExists(ctx interface{}, repoURL interface{}, project interface{}) *ArgoDB_RepositoryExists_Call {
	return &ArgoDB_RepositoryExists_Call{Call: _e.mock.On("RepositoryExists", ctx, repoURL, project)}
}

func (_c *ArgoDB_RepositoryExists_Call) Run(run func(ctx context.Context, repoURL string, project string)) *ArgoDB_RepositoryExists_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *ArgoDB_RepositoryExists_Call) Return(b bool, err error) *ArgoDB_RepositoryExists_Call {
	_c.Call.Return(b, err)
	return _c
}

func (_c *ArgoDB_RepositoryExists_Call) RunAndReturn(run func(ctx context.Context, repoURL string, project string) (bool, error)) *ArgoDB_RepositoryExists_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateCluster provides a mock function for the type ArgoDB
func (_mock *ArgoDB) UpdateCluster(ctx context.Context, c *v1alpha1.Cluster) (*v1alpha1.Cluster, error) {
	ret := _mock.Called(ctx, c)

	if len(ret) == 0 {
		panic("no return value specified for UpdateCluster")
	}

	var r0 *v1alpha1.Cluster
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *v1alpha1.Cluster) (*v1alpha1.Cluster, error)); ok {
		return returnFunc(ctx, c)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *v1alpha1.Cluster) *v1alpha1.Cluster); ok {
		r0 = returnFunc(ctx, c)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*v1alpha1.Cluster)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *v1alpha1.Cluster) error); ok {
		r1 = returnFunc(ctx, c)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ArgoDB_UpdateCluster_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateCluster'
type ArgoDB_UpdateCluster_Call struct {
	*mock.Call
}

// UpdateCluster is a helper method to define mock.On call
//   - ctx context.Context
//   - c *v1alpha1.Cluster
func (_e *ArgoDB_Expecter) UpdateCluster(ctx interface{}, c interface{}) *ArgoDB_UpdateCluster_Call {
	return &ArgoDB_UpdateCluster_Call{Call: _e.mock.On("UpdateCluster", ctx, c)}
}

func (_c *ArgoDB_UpdateCluster_Call) Run(run func(ctx context.Context, c *v1alpha1.Cluster)) *ArgoDB_UpdateCluster_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *v1alpha1.Cluster
		if args[1] != nil {
			arg1 = args[1].(*v1alpha1.Cluster)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *ArgoDB_UpdateCluster_Call) Return(cluster *v1alpha1.Cluster, err error) *ArgoDB_UpdateCluster_Call {
	_c.Call.Return(cluster, err)
	return _c
}

func (_c *ArgoDB_UpdateCluster_Call) RunAndReturn(run func(ctx context.Context, c *v1alpha1.Cluster) (*v1alpha1.Cluster, error)) *ArgoDB_UpdateCluster_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateRepository provides a mock function for the type ArgoDB
func (_mock *ArgoDB) UpdateRepository(ctx context.Context, r *v1alpha1.Repository) (*v1alpha1.Repository, error) {
	ret := _mock.Called(ctx, r)

	if len(ret) == 0 {
		panic("no return value specified for UpdateRepository")
	}

	var r0 *v1alpha1.Repository
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *v1alpha1.Repository) (*v1alpha1.Repository, error)); ok {
		return returnFunc(ctx, r)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *v1alpha1.Repository) *v1alpha1.Repository); ok {
		r0 = returnFunc(ctx, r)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*v1alpha1.Repository)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *v1alpha1.Repository) error); ok {
		r1 = returnFunc(ctx, r)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ArgoDB_UpdateRepository_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateRepository'
type ArgoDB_UpdateRepository_Call struct {
	*mock.Call
}

// UpdateRepository is a helper method to define mock.On call
//   - ctx context.Context
//   - r *v1alpha1.Repository
func (_e *ArgoDB_Expecter) UpdateRepository(ctx interface{}, r interface{}) *ArgoDB_UpdateRepository_Call {
	return &ArgoDB_UpdateRepository_Call{Call: _e.mock.On("UpdateRepository", ctx, r)}
}

func (_c *ArgoDB_UpdateRepository_Call) Run(run func(ctx context.Context, r *v1alpha1.Repository)) *ArgoDB_UpdateRepository_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *v1alpha1.Repository
		if args[1] != nil {
			arg1 = args[1].(*v1alpha1.Repository)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *ArgoDB_UpdateRepository_Call) Return(repository *v1alpha1.Repository, err error) *ArgoDB_UpdateRepository_Call {
	_c.Call.Return(repository, err)
	return _c
}

func (_c *ArgoDB_UpdateRepository_Call) RunAndReturn(run func(ctx context.Context, r *v1alpha1.Repository) (*v1alpha1.Repository, error)) *ArgoDB_UpdateRepository_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateRepositoryCredentials provides a mock function for the type ArgoDB
func (_mock *ArgoDB) UpdateRepositoryCredentials(ctx context.Context, r *v1alpha1.RepoCreds) (*v1alpha1.RepoCreds, error) {
	ret := _mock.Called(ctx, r)

	if len(ret) == 0 {
		panic("no return value specified for UpdateRepositoryCredentials")
	}

	var r0 *v1alpha1.RepoCreds
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *v1alpha1.RepoCreds) (*v1alpha1.RepoCreds, error)); ok {
		return returnFunc(ctx, r)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *v1alpha1.RepoCreds) *v1alpha1.RepoCreds); ok {
		r0 = returnFunc(ctx, r)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*v1alpha1.RepoCreds)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *v1alpha1.RepoCreds) error); ok {
		r1 = returnFunc(ctx, r)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ArgoDB_UpdateRepositoryCredentials_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateRepositoryCredentials'
type ArgoDB_UpdateRepositoryCredentials_Call struct {
	*mock.Call
}

// UpdateRepositoryCredentials is a helper method to define mock.On call
//   - ctx context.Context
//   - r *v1alpha1.RepoCreds
func (_e *ArgoDB_Expecter) UpdateRepositoryCredentials(ctx interface{}, r interface{}) *ArgoDB_UpdateRepositoryCredentials_Call {
	return &ArgoDB_UpdateRepositoryCredentials_Call{Call: _e.mock.On("UpdateRepositoryCredentials", ctx, r)}
}

func (_c *ArgoDB_UpdateRepositoryCredentials_Call) Run(run func(ctx context.Context, r *v1alpha1.RepoCreds)) *ArgoDB_UpdateRepositoryCredentials_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *v1alpha1.RepoCreds
		if args[1] != nil {
			arg1 = args[1].(*v1alpha1.RepoCreds)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *ArgoDB_UpdateRepositoryCredentials_Call) Return(repoCreds *v1alpha1.RepoCreds, err error) *ArgoDB_UpdateRepositoryCredentials_Call {
	_c.Call.Return(repoCreds, err)
	return _c
}

func (_c *ArgoDB_UpdateRepositoryCredentials_Call) RunAndReturn(run func(ctx context.Context, r *v1alpha1.RepoCreds) (*v1alpha1.RepoCreds, error)) *ArgoDB_UpdateRepositoryCredentials_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateWriteRepository provides a mock function for the type ArgoDB
func (_mock *ArgoDB) UpdateWriteRepository(ctx context.Context, r *v1alpha1.Repository) (*v1alpha1.Repository, error) {
	ret := _mock.Called(ctx, r)

	if len(ret) == 0 {
		panic("no return value specified for UpdateWriteRepository")
	}

	var r0 *v1alpha1.Repository
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *v1alpha1.Repository) (*v1alpha1.Repository, error)); ok {
		return returnFunc(ctx, r)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *v1alpha1.Repository) *v1alpha1.Repository); ok {
		r0 = returnFunc(ctx, r)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*v1alpha1.Repository)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *v1alpha1.Repository) error); ok {
		r1 = returnFunc(ctx, r)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ArgoDB_UpdateWriteRepository_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateWriteRepository'
type ArgoDB_UpdateWriteRepository_Call struct {
	*mock.Call
}

// UpdateWriteRepository is a helper method to define mock.On call
//   - ctx context.Context
//   - r *v1alpha1.Repository
func (_e *ArgoDB_Expecter) UpdateWriteRepository(ctx interface{}, r interface{}) *ArgoDB_UpdateWriteRepository_Call {
	return &ArgoDB_UpdateWriteRepository_Call{Call: _e.mock.On("UpdateWriteRepository", ctx, r)}
}

func (_c *ArgoDB_UpdateWriteRepository_Call) Run(run func(ctx context.Context, r *v1alpha1.Repository)) *ArgoDB_UpdateWriteRepository_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *v1alpha1.Repository
		if args[1] != nil {
			arg1 = args[1].(*v1alpha1.Repository)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *ArgoDB_UpdateWriteRepository_Call) Return(repository *v1alpha1.Repository, err error) *ArgoDB_UpdateWriteRepository_Call {
	_c.Call.Return(repository, err)
	return _c
}

func (_c *ArgoDB_UpdateWriteRepository_Call) RunAndReturn(run func(ctx context.Context, r *v1alpha1.Repository) (*v1alpha1.Repository, error)) *ArgoDB_UpdateWriteRepository_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateWriteRepositoryCredentials provides a mock function for the type ArgoDB
func (_mock *ArgoDB) UpdateWriteRepositoryCredentials(ctx context.Context, r *v1alpha1.RepoCreds) (*v1alpha1.RepoCreds, error) {
	ret := _mock.Called(ctx, r)

	if len(ret) == 0 {
		panic("no return value specified for UpdateWriteRepositoryCredentials")
	}

	var r0 *v1alpha1.RepoCreds
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *v1alpha1.RepoCreds) (*v1alpha1.RepoCreds, error)); ok {
		return returnFunc(ctx, r)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *v1alpha1.RepoCreds) *v1alpha1.RepoCreds); ok {
		r0 = returnFunc(ctx, r)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*v1alpha1.RepoCreds)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *v1alpha1.RepoCreds) error); ok {
		r1 = returnFunc(ctx, r)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ArgoDB_UpdateWriteRepositoryCredentials_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateWriteRepositoryCredentials'
type ArgoDB_UpdateWriteRepositoryCredentials_Call struct {
	*mock.Call
}

// UpdateWriteRepositoryCredentials is a helper method to define mock.On call
//   - ctx context.Context
//   - r *v1alpha1.RepoCreds
func (_e *ArgoDB_Expecter) UpdateWriteRepositoryCredentials(ctx interface{}, r interface{}) *ArgoDB_UpdateWriteRepositoryCredentials_Call {
	return &ArgoDB_UpdateWriteRepositoryCredentials_Call{Call: _e.mock.On("UpdateWriteRepositoryCredentials", ctx, r)}
}

func (_c *ArgoDB_UpdateWriteRepositoryCredentials_Call) Run(run func(ctx context.Context, r *v1alpha1.RepoCreds)) *ArgoDB_UpdateWriteRepositoryCredentials_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *v1alpha1.RepoCreds
		if args[1] != nil {
			arg1 = args[1].(*v1alpha1.RepoCreds)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *ArgoDB_UpdateWriteRepositoryCredentials_Call) Return(repoCreds *v1alpha1.RepoCreds, err error) *ArgoDB_UpdateWriteRepositoryCredentials_Call {
	_c.Call.Return(repoCreds, err)
	return _c
}

func (_c *ArgoDB_UpdateWriteRepositoryCredentials_Call) RunAndReturn(run func(ctx context.Context, r *v1alpha1.RepoCreds) (*v1alpha1.RepoCreds, error)) *ArgoDB_UpdateWriteRepositoryCredentials_Call {
	_c.Call.Return(run)
	return _c
}

// WatchClusters provides a mock function for the type ArgoDB
func (_mock *ArgoDB) WatchClusters(ctx context.Context, handleAddEvent func(cluster *v1alpha1.Cluster), handleModEvent func(oldCluster *v1alpha1.Cluster, newCluster *v1alpha1.Cluster), handleDeleteEvent func(clusterServer string)) error {
	ret := _mock.Called(ctx, handleAddEvent, handleModEvent, handleDeleteEvent)

	if len(ret) == 0 {
		panic("no return value specified for WatchClusters")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, func(cluster *v1alpha1.Cluster), func(oldCluster *v1alpha1.Cluster, newCluster *v1alpha1.Cluster), func(clusterServer string)) error); ok {
		r0 = returnFunc(ctx, handleAddEvent, handleModEvent, handleDeleteEvent)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// ArgoDB_WatchClusters_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WatchClusters'
type ArgoDB_WatchClusters_Call struct {
	*mock.Call
}

// WatchClusters is a helper method to define mock.On call
//   - ctx context.Context
//   - handleAddEvent func(cluster *v1alpha1.Cluster)
//   - handleModEvent func(oldCluster *v1alpha1.Cluster, newCluster *v1alpha1.Cluster)
//   - handleDeleteEvent func(clusterServer string)
func (_e *ArgoDB_Expecter) WatchClusters(ctx interface{}, handleAddEvent interface{}, handleModEvent interface{}, handleDeleteEvent interface{}) *ArgoDB_WatchClusters_Call {
	return &ArgoDB_WatchClusters_Call{Call: _e.mock.On("WatchClusters", ctx, handleAddEvent, handleModEvent, handleDeleteEvent)}
}

func (_c *ArgoDB_WatchClusters_Call) Run(run func(ctx context.Context, handleAddEvent func(cluster *v1alpha1.Cluster), handleModEvent func(oldCluster *v1alpha1.Cluster, newCluster *v1alpha1.Cluster), handleDeleteEvent func(clusterServer string))) *ArgoDB_WatchClusters_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 func(cluster *v1alpha1.Cluster)
		if args[1] != nil {
			arg1 = args[1].(func(cluster *v1alpha1.Cluster))
		}
		var arg2 func(oldCluster *v1alpha1.Cluster, newCluster *v1alpha1.Cluster)
		if args[2] != nil {
			arg2 = args[2].(func(oldCluster *v1alpha1.Cluster, newCluster *v1alpha1.Cluster))
		}
		var arg3 func(clusterServer string)
		if args[3] != nil {
			arg3 = args[3].(func(clusterServer string))
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *ArgoDB_WatchClusters_Call) Return(err error) *ArgoDB_WatchClusters_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *ArgoDB_WatchClusters_Call) RunAndReturn(run func(ctx context.Context, handleAddEvent func(cluster *v1alpha1.Cluster), handleModEvent func(oldCluster *v1alpha1.Cluster, newCluster *v1alpha1.Cluster), handleDeleteEvent func(clusterServer string)) error) *ArgoDB_WatchClusters_Call {
	_c.Call.Return(run)
	return _c
}

// WriteRepositoryExists provides a mock function for the type ArgoDB
func (_mock *ArgoDB) WriteRepositoryExists(ctx context.Context, repoURL string, project string) (bool, error) {
	ret := _mock.Called(ctx, repoURL, project)

	if len(ret) == 0 {
		panic("no return value specified for WriteRepositoryExists")
	}

	var r0 bool
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string) (bool, error)); ok {
		return returnFunc(ctx, repoURL, project)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string) bool); ok {
		r0 = returnFunc(ctx, repoURL, project)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = returnFunc(ctx, repoURL, project)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ArgoDB_WriteRepositoryExists_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WriteRepositoryExists'
type ArgoDB_WriteRepositoryExists_Call struct {
	*mock.Call
}

// WriteRepositoryExists is a helper method to define mock.On call
//   - ctx context.Context
//   - repoURL string
//   - project string
func (_e *ArgoDB_Expecter) WriteRepositoryExists(ctx interface{}, repoURL interface{}, project interface{}) *ArgoDB_WriteRepositoryExists_Call {
	return &ArgoDB_WriteRepositoryExists_Call{Call: _e.mock.On("WriteRepositoryExists", ctx, repoURL, project)}
}

func (_c *ArgoDB_WriteRepositoryExists_Call) Run(run func(ctx context.Context, repoURL string, project string)) *ArgoDB_WriteRepositoryExists_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *ArgoDB_WriteRepositoryExists_Call) Return(b bool, err error) *ArgoDB_WriteRepositoryExists_Call {
	_c.Call.Return(b, err)
	return _c
}

func (_c *ArgoDB_WriteRepositoryExists_Call) RunAndReturn(run func(ctx context.Context, repoURL string, project string) (bool, error)) *ArgoDB_WriteRepositoryExists_Call {
	_c.Call.Return(run)
	return _c
}
